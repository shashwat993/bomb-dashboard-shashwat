{"ast":null,"code":"'use strict';\n\nvar urilib = require('url');\n\nvar attribute = require('./attribute');\n\nvar helpers = require('./helpers');\n\nvar scanSchema = require('./scan').scan;\n\nvar ValidatorResult = helpers.ValidatorResult;\nvar ValidatorResultError = helpers.ValidatorResultError;\nvar SchemaError = helpers.SchemaError;\nvar SchemaContext = helpers.SchemaContext; //var anonymousBase = 'vnd.jsonschema:///';\n\nvar anonymousBase = '/';\n/**\n * Creates a new Validator object\n * @name Validator\n * @constructor\n */\n\nvar Validator = function Validator() {\n  // Allow a validator instance to override global custom formats or to have their\n  // own custom formats.\n  this.customFormats = Object.create(Validator.prototype.customFormats);\n  this.schemas = {};\n  this.unresolvedRefs = []; // Use Object.create to make this extensible without Validator instances stepping on each other's toes.\n\n  this.types = Object.create(types);\n  this.attributes = Object.create(attribute.validators);\n}; // Allow formats to be registered globally.\n\n\nValidator.prototype.customFormats = {}; // Hint at the presence of a property\n\nValidator.prototype.schemas = null;\nValidator.prototype.types = null;\nValidator.prototype.attributes = null;\nValidator.prototype.unresolvedRefs = null;\n/**\n * Adds a schema with a certain urn to the Validator instance.\n * @param schema\n * @param urn\n * @return {Object}\n */\n\nValidator.prototype.addSchema = function addSchema(schema, base) {\n  var self = this;\n\n  if (!schema) {\n    return null;\n  }\n\n  var scan = scanSchema(base || anonymousBase, schema);\n  var ourUri = base || schema.$id || schema.id;\n\n  for (var uri in scan.id) {\n    this.schemas[uri] = scan.id[uri];\n  }\n\n  for (var uri in scan.ref) {\n    // If this schema is already defined, it will be filtered out by the next step\n    this.unresolvedRefs.push(uri);\n  } // Remove newly defined schemas from unresolvedRefs\n\n\n  this.unresolvedRefs = this.unresolvedRefs.filter(function (uri) {\n    return typeof self.schemas[uri] === 'undefined';\n  });\n  return this.schemas[ourUri];\n};\n\nValidator.prototype.addSubSchemaArray = function addSubSchemaArray(baseuri, schemas) {\n  if (!Array.isArray(schemas)) return;\n\n  for (var i = 0; i < schemas.length; i++) {\n    this.addSubSchema(baseuri, schemas[i]);\n  }\n};\n\nValidator.prototype.addSubSchemaObject = function addSubSchemaArray(baseuri, schemas) {\n  if (!schemas || typeof schemas != 'object') return;\n\n  for (var p in schemas) {\n    this.addSubSchema(baseuri, schemas[p]);\n  }\n};\n/**\n * Sets all the schemas of the Validator instance.\n * @param schemas\n */\n\n\nValidator.prototype.setSchemas = function setSchemas(schemas) {\n  this.schemas = schemas;\n};\n/**\n * Returns the schema of a certain urn\n * @param urn\n */\n\n\nValidator.prototype.getSchema = function getSchema(urn) {\n  return this.schemas[urn];\n};\n/**\n * Validates instance against the provided schema\n * @param instance\n * @param schema\n * @param [options]\n * @param [ctx]\n * @return {Array}\n */\n\n\nValidator.prototype.validate = function validate(instance, schema, options, ctx) {\n  if (typeof schema !== 'boolean' && typeof schema !== 'object' || schema === null) {\n    throw new SchemaError('Expected `schema` to be an object or boolean');\n  }\n\n  if (!options) {\n    options = {};\n  } // This section indexes subschemas in the provided schema, so they don't need to be added with Validator#addSchema\n  // This will work so long as the function at uri.resolve() will resolve a relative URI to a relative URI\n\n\n  var id = schema.$id || schema.id;\n  var base = urilib.resolve(options.base || anonymousBase, id || '');\n\n  if (!ctx) {\n    ctx = new SchemaContext(schema, options, [], base, Object.create(this.schemas));\n\n    if (!ctx.schemas[base]) {\n      ctx.schemas[base] = schema;\n    }\n\n    var found = scanSchema(base, schema);\n\n    for (var n in found.id) {\n      var sch = found.id[n];\n      ctx.schemas[n] = sch;\n    }\n  }\n\n  if (options.required && instance === undefined) {\n    var result = new ValidatorResult(instance, schema, options, ctx);\n    result.addError('is required, but is undefined');\n    return result;\n  }\n\n  var result = this.validateSchema(instance, schema, options, ctx);\n\n  if (!result) {\n    throw new Error('Result undefined');\n  } else if (options.throwAll && result.errors.length) {\n    throw new ValidatorResultError(result);\n  }\n\n  return result;\n};\n/**\n* @param Object schema\n* @return mixed schema uri or false\n*/\n\n\nfunction shouldResolve(schema) {\n  var ref = typeof schema === 'string' ? schema : schema.$ref;\n  if (typeof ref == 'string') return ref;\n  return false;\n}\n/**\n * Validates an instance against the schema (the actual work horse)\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @private\n * @return {ValidatorResult}\n */\n\n\nValidator.prototype.validateSchema = function validateSchema(instance, schema, options, ctx) {\n  var result = new ValidatorResult(instance, schema, options, ctx); // Support for the true/false schemas\n\n  if (typeof schema === 'boolean') {\n    if (schema === true) {\n      // `true` is always valid\n      schema = {};\n    } else if (schema === false) {\n      // `false` is always invalid\n      schema = {\n        type: []\n      };\n    }\n  } else if (!schema) {\n    // This might be a string\n    throw new Error(\"schema is undefined\");\n  }\n\n  if (schema['extends']) {\n    if (Array.isArray(schema['extends'])) {\n      var schemaobj = {\n        schema: schema,\n        ctx: ctx\n      };\n      schema['extends'].forEach(this.schemaTraverser.bind(this, schemaobj));\n      schema = schemaobj.schema;\n      schemaobj.schema = null;\n      schemaobj.ctx = null;\n      schemaobj = null;\n    } else {\n      schema = helpers.deepMerge(schema, this.superResolve(schema['extends'], ctx));\n    }\n  } // If passed a string argument, load that schema URI\n\n\n  var switchSchema = shouldResolve(schema);\n\n  if (switchSchema) {\n    var resolved = this.resolve(schema, switchSchema, ctx);\n    var subctx = new SchemaContext(resolved.subschema, options, ctx.path, resolved.switchSchema, ctx.schemas);\n    return this.validateSchema(instance, resolved.subschema, options, subctx);\n  }\n\n  var skipAttributes = options && options.skipAttributes || []; // Validate each schema attribute against the instance\n\n  for (var key in schema) {\n    if (!attribute.ignoreProperties[key] && skipAttributes.indexOf(key) < 0) {\n      var validatorErr = null;\n      var validator = this.attributes[key];\n\n      if (validator) {\n        validatorErr = validator.call(this, instance, schema, options, ctx);\n      } else if (options.allowUnknownAttributes === false) {\n        // This represents an error with the schema itself, not an invalid instance\n        throw new SchemaError(\"Unsupported attribute: \" + key, schema);\n      }\n\n      if (validatorErr) {\n        result.importErrors(validatorErr);\n      }\n    }\n  }\n\n  if (typeof options.rewrite == 'function') {\n    var value = options.rewrite.call(this, instance, schema, options, ctx);\n    result.instance = value;\n  }\n\n  return result;\n};\n/**\n* @private\n* @param Object schema\n* @param SchemaContext ctx\n* @returns Object schema or resolved schema\n*/\n\n\nValidator.prototype.schemaTraverser = function schemaTraverser(schemaobj, s) {\n  schemaobj.schema = helpers.deepMerge(schemaobj.schema, this.superResolve(s, schemaobj.ctx));\n};\n/**\n* @private\n* @param Object schema\n* @param SchemaContext ctx\n* @returns Object schema or resolved schema\n*/\n\n\nValidator.prototype.superResolve = function superResolve(schema, ctx) {\n  var ref = shouldResolve(schema);\n\n  if (ref) {\n    return this.resolve(schema, ref, ctx).subschema;\n  }\n\n  return schema;\n};\n/**\n* @private\n* @param Object schema\n* @param Object switchSchema\n* @param SchemaContext ctx\n* @return Object resolved schemas {subschema:String, switchSchema: String}\n* @throws SchemaError\n*/\n\n\nValidator.prototype.resolve = function resolve(schema, switchSchema, ctx) {\n  switchSchema = ctx.resolve(switchSchema); // First see if the schema exists under the provided URI\n\n  if (ctx.schemas[switchSchema]) {\n    return {\n      subschema: ctx.schemas[switchSchema],\n      switchSchema: switchSchema\n    };\n  } // Else try walking the property pointer\n\n\n  var parsed = urilib.parse(switchSchema);\n  var fragment = parsed && parsed.hash;\n  var document = fragment && fragment.length && switchSchema.substr(0, switchSchema.length - fragment.length);\n\n  if (!document || !ctx.schemas[document]) {\n    throw new SchemaError(\"no such schema <\" + switchSchema + \">\", schema);\n  }\n\n  var subschema = helpers.objectGetPath(ctx.schemas[document], fragment.substr(1));\n\n  if (subschema === undefined) {\n    throw new SchemaError(\"no such schema \" + fragment + \" located in <\" + document + \">\", schema);\n  }\n\n  return {\n    subschema: subschema,\n    switchSchema: switchSchema\n  };\n};\n/**\n * Tests whether the instance if of a certain type.\n * @private\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @param type\n * @return {boolean}\n */\n\n\nValidator.prototype.testType = function validateType(instance, schema, options, ctx, type) {\n  if (type === undefined) {\n    return;\n  } else if (type === null) {\n    throw new SchemaError('Unexpected null in \"type\" keyword');\n  }\n\n  if (typeof this.types[type] == 'function') {\n    return this.types[type].call(this, instance);\n  }\n\n  if (type && typeof type == 'object') {\n    var res = this.validateSchema(instance, type, options, ctx);\n    return res === undefined || !(res && res.errors.length);\n  } // Undefined or properties not on the list are acceptable, same as not being defined\n\n\n  return true;\n};\n\nvar types = Validator.prototype.types = {};\n\ntypes.string = function testString(instance) {\n  return typeof instance == 'string';\n};\n\ntypes.number = function testNumber(instance) {\n  // isFinite returns false for NaN, Infinity, and -Infinity\n  return typeof instance == 'number' && isFinite(instance);\n};\n\ntypes.integer = function testInteger(instance) {\n  return typeof instance == 'number' && instance % 1 === 0;\n};\n\ntypes.boolean = function testBoolean(instance) {\n  return typeof instance == 'boolean';\n};\n\ntypes.array = function testArray(instance) {\n  return Array.isArray(instance);\n};\n\ntypes['null'] = function testNull(instance) {\n  return instance === null;\n};\n\ntypes.date = function testDate(instance) {\n  return instance instanceof Date;\n};\n\ntypes.any = function testAny(instance) {\n  return true;\n};\n\ntypes.object = function testObject(instance) {\n  // TODO: fix this - see #15\n  return instance && typeof instance === 'object' && !Array.isArray(instance) && !(instance instanceof Date);\n};\n\nmodule.exports = Validator;","map":{"version":3,"sources":["/home/shashwat/Projects/Intern/node_modules/jsonschema/lib/validator.js"],"names":["urilib","require","attribute","helpers","scanSchema","scan","ValidatorResult","ValidatorResultError","SchemaError","SchemaContext","anonymousBase","Validator","customFormats","Object","create","prototype","schemas","unresolvedRefs","types","attributes","validators","addSchema","schema","base","self","ourUri","$id","id","uri","ref","push","filter","addSubSchemaArray","baseuri","Array","isArray","i","length","addSubSchema","addSubSchemaObject","p","setSchemas","getSchema","urn","validate","instance","options","ctx","resolve","found","n","sch","required","undefined","result","addError","validateSchema","Error","throwAll","errors","shouldResolve","$ref","type","schemaobj","forEach","schemaTraverser","bind","deepMerge","superResolve","switchSchema","resolved","subctx","subschema","path","skipAttributes","key","ignoreProperties","indexOf","validatorErr","validator","call","allowUnknownAttributes","importErrors","rewrite","value","s","parsed","parse","fragment","hash","document","substr","objectGetPath","testType","validateType","res","string","testString","number","testNumber","isFinite","integer","testInteger","boolean","testBoolean","array","testArray","testNull","date","testDate","Date","any","testAny","object","testObject","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nvar urilib = require('url');\n\nvar attribute = require('./attribute');\nvar helpers = require('./helpers');\nvar scanSchema = require('./scan').scan;\nvar ValidatorResult = helpers.ValidatorResult;\nvar ValidatorResultError = helpers.ValidatorResultError;\nvar SchemaError = helpers.SchemaError;\nvar SchemaContext = helpers.SchemaContext;\n//var anonymousBase = 'vnd.jsonschema:///';\nvar anonymousBase = '/';\n\n/**\n * Creates a new Validator object\n * @name Validator\n * @constructor\n */\nvar Validator = function Validator () {\n  // Allow a validator instance to override global custom formats or to have their\n  // own custom formats.\n  this.customFormats = Object.create(Validator.prototype.customFormats);\n  this.schemas = {};\n  this.unresolvedRefs = [];\n\n  // Use Object.create to make this extensible without Validator instances stepping on each other's toes.\n  this.types = Object.create(types);\n  this.attributes = Object.create(attribute.validators);\n};\n\n// Allow formats to be registered globally.\nValidator.prototype.customFormats = {};\n\n// Hint at the presence of a property\nValidator.prototype.schemas = null;\nValidator.prototype.types = null;\nValidator.prototype.attributes = null;\nValidator.prototype.unresolvedRefs = null;\n\n/**\n * Adds a schema with a certain urn to the Validator instance.\n * @param schema\n * @param urn\n * @return {Object}\n */\nValidator.prototype.addSchema = function addSchema (schema, base) {\n  var self = this;\n  if (!schema) {\n    return null;\n  }\n  var scan = scanSchema(base||anonymousBase, schema);\n  var ourUri = base || schema.$id || schema.id;\n  for(var uri in scan.id){\n    this.schemas[uri] = scan.id[uri];\n  }\n  for(var uri in scan.ref){\n    // If this schema is already defined, it will be filtered out by the next step\n    this.unresolvedRefs.push(uri);\n  }\n  // Remove newly defined schemas from unresolvedRefs\n  this.unresolvedRefs = this.unresolvedRefs.filter(function(uri){\n    return typeof self.schemas[uri]==='undefined';\n  });\n  return this.schemas[ourUri];\n};\n\nValidator.prototype.addSubSchemaArray = function addSubSchemaArray(baseuri, schemas) {\n  if(!Array.isArray(schemas)) return;\n  for(var i=0; i<schemas.length; i++){\n    this.addSubSchema(baseuri, schemas[i]);\n  }\n};\n\nValidator.prototype.addSubSchemaObject = function addSubSchemaArray(baseuri, schemas) {\n  if(!schemas || typeof schemas!='object') return;\n  for(var p in schemas){\n    this.addSubSchema(baseuri, schemas[p]);\n  }\n};\n\n\n\n/**\n * Sets all the schemas of the Validator instance.\n * @param schemas\n */\nValidator.prototype.setSchemas = function setSchemas (schemas) {\n  this.schemas = schemas;\n};\n\n/**\n * Returns the schema of a certain urn\n * @param urn\n */\nValidator.prototype.getSchema = function getSchema (urn) {\n  return this.schemas[urn];\n};\n\n/**\n * Validates instance against the provided schema\n * @param instance\n * @param schema\n * @param [options]\n * @param [ctx]\n * @return {Array}\n */\nValidator.prototype.validate = function validate (instance, schema, options, ctx) {\n  if((typeof schema !== 'boolean' && typeof schema !== 'object') || schema === null){\n    throw new SchemaError('Expected `schema` to be an object or boolean');\n  }\n  if (!options) {\n    options = {};\n  }\n  // This section indexes subschemas in the provided schema, so they don't need to be added with Validator#addSchema\n  // This will work so long as the function at uri.resolve() will resolve a relative URI to a relative URI\n  var id = schema.$id || schema.id;\n  var base = urilib.resolve(options.base||anonymousBase, id||'');\n  if(!ctx){\n    ctx = new SchemaContext(schema, options, [], base, Object.create(this.schemas));\n    if (!ctx.schemas[base]) {\n      ctx.schemas[base] = schema;\n    }\n    var found = scanSchema(base, schema);\n    for(var n in found.id){\n      var sch = found.id[n];\n      ctx.schemas[n] = sch;\n    }\n  }\n  if(options.required && instance===undefined){\n    var result = new ValidatorResult(instance, schema, options, ctx);\n    result.addError('is required, but is undefined');\n    return result;\n  }\n  var result = this.validateSchema(instance, schema, options, ctx);\n  if (!result) {\n    throw new Error('Result undefined');\n  }else if(options.throwAll && result.errors.length){\n    throw new ValidatorResultError(result);\n  }\n  return result;\n};\n\n/**\n* @param Object schema\n* @return mixed schema uri or false\n*/\nfunction shouldResolve(schema) {\n  var ref = (typeof schema === 'string') ? schema : schema.$ref;\n  if (typeof ref=='string') return ref;\n  return false;\n}\n\n/**\n * Validates an instance against the schema (the actual work horse)\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @private\n * @return {ValidatorResult}\n */\nValidator.prototype.validateSchema = function validateSchema (instance, schema, options, ctx) {\n  var result = new ValidatorResult(instance, schema, options, ctx);\n\n  // Support for the true/false schemas\n  if(typeof schema==='boolean') {\n    if(schema===true){\n      // `true` is always valid\n      schema = {};\n    }else if(schema===false){\n      // `false` is always invalid\n      schema = {type: []};\n    }\n  }else if(!schema){\n    // This might be a string\n    throw new Error(\"schema is undefined\");\n  }\n\n  if (schema['extends']) {\n    if (Array.isArray(schema['extends'])) {\n      var schemaobj = {schema: schema, ctx: ctx};\n      schema['extends'].forEach(this.schemaTraverser.bind(this, schemaobj));\n      schema = schemaobj.schema;\n      schemaobj.schema = null;\n      schemaobj.ctx = null;\n      schemaobj = null;\n    } else {\n      schema = helpers.deepMerge(schema, this.superResolve(schema['extends'], ctx));\n    }\n  }\n\n  // If passed a string argument, load that schema URI\n  var switchSchema = shouldResolve(schema);\n  if (switchSchema) {\n    var resolved = this.resolve(schema, switchSchema, ctx);\n    var subctx = new SchemaContext(resolved.subschema, options, ctx.path, resolved.switchSchema, ctx.schemas);\n    return this.validateSchema(instance, resolved.subschema, options, subctx);\n  }\n\n  var skipAttributes = options && options.skipAttributes || [];\n  // Validate each schema attribute against the instance\n  for (var key in schema) {\n    if (!attribute.ignoreProperties[key] && skipAttributes.indexOf(key) < 0) {\n      var validatorErr = null;\n      var validator = this.attributes[key];\n      if (validator) {\n        validatorErr = validator.call(this, instance, schema, options, ctx);\n      } else if (options.allowUnknownAttributes === false) {\n        // This represents an error with the schema itself, not an invalid instance\n        throw new SchemaError(\"Unsupported attribute: \" + key, schema);\n      }\n      if (validatorErr) {\n        result.importErrors(validatorErr);\n      }\n    }\n  }\n\n  if (typeof options.rewrite == 'function') {\n    var value = options.rewrite.call(this, instance, schema, options, ctx);\n    result.instance = value;\n  }\n  return result;\n};\n\n/**\n* @private\n* @param Object schema\n* @param SchemaContext ctx\n* @returns Object schema or resolved schema\n*/\nValidator.prototype.schemaTraverser = function schemaTraverser (schemaobj, s) {\n  schemaobj.schema = helpers.deepMerge(schemaobj.schema, this.superResolve(s, schemaobj.ctx));\n};\n\n/**\n* @private\n* @param Object schema\n* @param SchemaContext ctx\n* @returns Object schema or resolved schema\n*/\nValidator.prototype.superResolve = function superResolve (schema, ctx) {\n  var ref = shouldResolve(schema);\n  if(ref) {\n    return this.resolve(schema, ref, ctx).subschema;\n  }\n  return schema;\n};\n\n/**\n* @private\n* @param Object schema\n* @param Object switchSchema\n* @param SchemaContext ctx\n* @return Object resolved schemas {subschema:String, switchSchema: String}\n* @throws SchemaError\n*/\nValidator.prototype.resolve = function resolve (schema, switchSchema, ctx) {\n  switchSchema = ctx.resolve(switchSchema);\n  // First see if the schema exists under the provided URI\n  if (ctx.schemas[switchSchema]) {\n    return {subschema: ctx.schemas[switchSchema], switchSchema: switchSchema};\n  }\n  // Else try walking the property pointer\n  var parsed = urilib.parse(switchSchema);\n  var fragment = parsed && parsed.hash;\n  var document = fragment && fragment.length && switchSchema.substr(0, switchSchema.length - fragment.length);\n  if (!document || !ctx.schemas[document]) {\n    throw new SchemaError(\"no such schema <\" + switchSchema + \">\", schema);\n  }\n  var subschema = helpers.objectGetPath(ctx.schemas[document], fragment.substr(1));\n  if(subschema===undefined){\n    throw new SchemaError(\"no such schema \" + fragment + \" located in <\" + document + \">\", schema);\n  }\n  return {subschema: subschema, switchSchema: switchSchema};\n};\n\n/**\n * Tests whether the instance if of a certain type.\n * @private\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @param type\n * @return {boolean}\n */\nValidator.prototype.testType = function validateType (instance, schema, options, ctx, type) {\n  if(type===undefined){\n    return;\n  }else if(type===null){\n    throw new SchemaError('Unexpected null in \"type\" keyword');\n  }\n  if (typeof this.types[type] == 'function') {\n    return this.types[type].call(this, instance);\n  }\n  if (type && typeof type == 'object') {\n    var res = this.validateSchema(instance, type, options, ctx);\n    return res === undefined || !(res && res.errors.length);\n  }\n  // Undefined or properties not on the list are acceptable, same as not being defined\n  return true;\n};\n\nvar types = Validator.prototype.types = {};\ntypes.string = function testString (instance) {\n  return typeof instance == 'string';\n};\ntypes.number = function testNumber (instance) {\n  // isFinite returns false for NaN, Infinity, and -Infinity\n  return typeof instance == 'number' && isFinite(instance);\n};\ntypes.integer = function testInteger (instance) {\n  return (typeof instance == 'number') && instance % 1 === 0;\n};\ntypes.boolean = function testBoolean (instance) {\n  return typeof instance == 'boolean';\n};\ntypes.array = function testArray (instance) {\n  return Array.isArray(instance);\n};\ntypes['null'] = function testNull (instance) {\n  return instance === null;\n};\ntypes.date = function testDate (instance) {\n  return instance instanceof Date;\n};\ntypes.any = function testAny (instance) {\n  return true;\n};\ntypes.object = function testObject (instance) {\n  // TODO: fix this - see #15\n  return instance && (typeof instance === 'object') && !(Array.isArray(instance)) && !(instance instanceof Date);\n};\n\nmodule.exports = Validator;\n"]},"metadata":{},"sourceType":"script"}