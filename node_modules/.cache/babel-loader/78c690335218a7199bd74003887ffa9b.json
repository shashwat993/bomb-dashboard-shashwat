{"ast":null,"code":"// import { Fetcher, Route, Token } from '@uniswap/sdk';\n//import { Fetcher as FetcherSpirit, Token as TokenSpirit } from '@spiritswap/sdk';\nimport { Fetcher, Route, Token } from '@pancakeswap/sdk';\nimport { BigNumber, Contract, ethers } from 'ethers';\nimport { decimalToBalance } from './ether-utils';\nimport ERC20 from './ERC20';\nimport { getFullDisplayBalance, getDisplayBalance } from '../utils/formatBalance';\nimport { getDefaultProvider } from '../utils/provider';\nimport IUniswapV2PairABI from './IUniswapV2Pair.abi.json';\nimport IBombBorrowableABI from './IBombBorrowable.abi.json';\nimport config, { bankDefinitions } from '../config';\nimport moment from 'moment';\nimport { parseUnits } from 'ethers/lib/utils';\nimport { BNB_TICKER, SPOOKY_ROUTER_ADDR, BOMB_TICKER } from '../utils/constants';\nimport { bombMaxi } from '../services/graph';\n/**\n * An API module of Bomb Money contracts.\n * All contract-interacting domain logic should be defined in here.\n */\n\nexport class BombFinance {\n  constructor(cfg) {\n    this.myAccount = void 0;\n    this.provider = void 0;\n    this.signer = void 0;\n    this.config = void 0;\n    this.contracts = void 0;\n    this.externalTokens = void 0;\n    this.boardroomVersionOfUser = void 0;\n    this.BOMBBTCB_LP = void 0;\n    this.BOMB = void 0;\n    this.BUSD = void 0;\n    this.BSHARE = void 0;\n    this.BBOND = void 0;\n    this.XBOMB = void 0;\n    this.BNB = void 0;\n    this.BTC = void 0;\n    this.BOMB_BORROWABLE = void 0;\n    this.BTCB_BORROWABLE = void 0;\n    this.BBOMB_BOMB = void 0;\n    this.BBOMB_BTCB = void 0;\n    this.BBOMBBOMB = void 0;\n    this.BBOMBBTCB = void 0;\n    this.BUSMBUSD_LP = void 0;\n    this.BUSM = void 0;\n    this.BOMB_MAXI = void 0;\n    this.BSHARE_MAXI = void 0;\n    const {\n      deployments,\n      externalTokens\n    } = cfg;\n    const provider = getDefaultProvider(); // loads contracts from deployments\n\n    this.contracts = {};\n\n    for (const [name, deployment] of Object.entries(deployments)) {\n      this.contracts[name] = new Contract(deployment.address, deployment.abi, provider);\n    }\n\n    this.externalTokens = {};\n\n    for (const [symbol, [address, decimal]] of Object.entries(externalTokens)) {\n      this.externalTokens[symbol] = new ERC20(address, provider, symbol, decimal);\n    }\n\n    this.BOMB = new ERC20(deployments.Bomb.address, provider, 'BOMB');\n    this.BSHARE = new ERC20(deployments.BShare.address, provider, 'BSHARE');\n    this.BBOND = new ERC20(deployments.BBond.address, provider, 'BBOND');\n    this.BNB = this.externalTokens['WBNB'];\n    this.BTC = this.externalTokens['BTCB'];\n    this.XBOMB = new ERC20(deployments.xBOMB.address, provider, 'XBOMB');\n    this.BUSM = this.externalTokens['BUSM'];\n    this.BUSD = this.externalTokens['BUSD']; // this.BBOMB_BOMB = new ERC20(deployments.BombBorrowable.address, provider, 'bBOMB');\n    // this.BBOMB_BTCB = new ERC20(deployments.BtcbBorrowable.address, provider, 'bBOMB');\n    // this.BBOMB_BOMB = new Contract(externalTokens['BBOMB-BOMB'][0], IBombBorrowableABI, provider);\n    // this.BBOMB_BTCB = new Contract(externalTokens['BBOMB-BTCB'][0], IBombBorrowableABI, provider);\n\n    this.BBOMB_BOMB = new ERC20(deployments.BombBorrowable.address, provider, 'bBOMB');\n    this.BBOMBBOMB = this.externalTokens['BBOMB-BOMB'];\n    this.BBOMBBTCB = this.externalTokens['BBOMB-BTCB'];\n    this.BBOMB_BTCB = new ERC20(deployments.BtcbBorrowable.address, provider, 'bBOMB');\n    this.BOMB_BORROWABLE = new Contract(externalTokens['BBOMB-BOMB'][0], IBombBorrowableABI, provider);\n    this.BTCB_BORROWABLE = new Contract(externalTokens['BBOMB-BTCB'][0], IBombBorrowableABI, provider);\n    this.BOMB_MAXI = new ERC20(deployments.BombMaxiLPBShareRewardPool.address, provider, '80BOMB-20BTCB-LP');\n    this.BSHARE_MAXI = new ERC20(deployments.BshareMaxiLPBShareRewardPool.address, provider, '80BSHARE-20WBNB-LP'); // Uniswap V2 Pair\n\n    this.BOMBBTCB_LP = new Contract(externalTokens['BOMB-BTCB-LP'][0], IUniswapV2PairABI, provider);\n    this.BUSMBUSD_LP = new Contract(externalTokens['BUSM-BUSD-LP'][0], IUniswapV2PairABI, provider);\n    this.config = cfg;\n    this.provider = provider;\n  }\n  /**\n   * @param provider From an unlocked wallet. (e.g. Metamask)\n   * @param account An address of unlocked wallet account.\n   */\n\n\n  unlockWallet(provider, account) {\n    const newProvider = new ethers.providers.Web3Provider(provider, this.config.chainId);\n    this.signer = newProvider.getSigner(0);\n    this.myAccount = account;\n\n    for (const [name, contract] of Object.entries(this.contracts)) {\n      this.contracts[name] = contract.connect(this.signer);\n    }\n\n    const tokens = [this.BOMB, this.BSHARE, this.BBOND, ...Object.values(this.externalTokens)];\n\n    for (const token of tokens) {\n      token.connect(this.signer);\n    }\n\n    this.BOMBBTCB_LP = this.BOMBBTCB_LP.connect(this.signer);\n    console.log(`ðŸ”“ Wallet is unlocked. Welcome, ${account}!`);\n    this.fetchBoardroomVersionOfUser().then(version => this.boardroomVersionOfUser = version).catch(err => {\n      console.error(`Failed to fetch boardroom version: ${err.stack}`);\n      this.boardroomVersionOfUser = 'latest';\n    });\n  }\n\n  get isUnlocked() {\n    return !!this.myAccount;\n  } //===================================================================\n  //===================== GET ASSET STATS =============================\n  //===================FROM APE TO DISPLAY =========================\n  //=========================IN HOME PAGE==============================\n  //===================================================================\n\n\n  async getBombStat() {\n    const {\n      BombRewardPool,\n      BombGenesisRewardPool\n    } = this.contracts;\n    const supply = await this.BOMB.totalSupply();\n    const bombRewardPoolSupply = await this.BOMB.balanceOf(BombGenesisRewardPool.address);\n    const bombRewardPoolSupply2 = await this.BOMB.balanceOf(BombRewardPool.address);\n    const bombCirculatingSupply = supply.sub(bombRewardPoolSupply).sub(bombRewardPoolSupply2); //  const priceInBNB = await this.getTokenPriceFromPancakeswap(this.BOMB);\n    //const priceInBNBstring = priceInBNB.toString();\n\n    const priceInBTC = await this.getTokenPriceFromPancakeswapBTC(this.BOMB); // const priceOfOneBNB = await this.getWBNBPriceFromPancakeswap();\n\n    const priceOfOneBTC = await this.getBTCBPriceFromPancakeswap(); //const priceInDollars = await this.getTokenPriceFromPancakeswapBOMBUSD();\n\n    const priceOfBombInDollars = (Number(priceInBTC) * Number(priceOfOneBTC) / 10000).toFixed(2); //console.log('priceOfBombInDollars', priceOfBombInDollars);\n\n    return {\n      //  tokenInFtm: (Number(priceInBNB) * 100).toString(),\n      tokenInFtm: priceInBTC.toString(),\n      priceInDollars: priceOfBombInDollars,\n      totalSupply: getDisplayBalance(supply, this.BOMB.decimal, 0),\n      circulatingSupply: getDisplayBalance(bombCirculatingSupply, this.BOMB.decimal, 0)\n    };\n  }\n\n  async getBTCPriceUSD() {\n    const priceOfOneBTC = await this.getBTCBPriceFromPancakeswap();\n    return Number(priceOfOneBTC);\n  }\n  /**\n   * Calculates various stats for the requested LP\n   * @param name of the LP token to load stats for\n   * @returns\n   */\n\n\n  async getLPStat(name) {\n    // console.log('NAME', name);\n    const lpToken = this.externalTokens[name];\n    const lpTokenSupplyBN = await lpToken.totalSupply();\n    const lpTokenSupply = getDisplayBalance(lpTokenSupplyBN, 18);\n    const token0 = name.startsWith('BOMB') ? this.BOMB : this.BSHARE; // console.log('NAME', name);\n\n    const isBomb = name.startsWith('BOMB');\n    const tokenAmountBN = await token0.balanceOf(lpToken.address);\n    const tokenAmount = getDisplayBalance(tokenAmountBN, 18);\n    const ftmAmountBN = await this.BNB.balanceOf(lpToken.address);\n    const ftmAmount = getDisplayBalance(ftmAmountBN, 18);\n    const tokenAmountInOneLP = Number(tokenAmount) / Number(lpTokenSupply);\n    const ftmAmountInOneLP = Number(ftmAmount) / Number(lpTokenSupply);\n    const lpTokenPrice = await this.getLPTokenPrice(lpToken, token0, isBomb);\n    const lpTokenPriceFixed = Number(lpTokenPrice).toFixed(2).toString();\n    const liquidity = (Number(lpTokenSupply) * Number(lpTokenPrice)).toFixed(2).toString();\n    return {\n      tokenAmount: tokenAmountInOneLP.toFixed(2).toString(),\n      ftmAmount: ftmAmountInOneLP.toFixed(2).toString(),\n      priceOfOne: lpTokenPriceFixed,\n      totalLiquidity: liquidity,\n      totalSupply: Number(lpTokenSupply).toFixed(2).toString()\n    };\n  }\n\n  async getLPStatBTC(name) {\n    const lpToken = this.externalTokens[name];\n    const lpTokenSupplyBN = await lpToken.totalSupply();\n    const lpTokenSupply = getDisplayBalance(lpTokenSupplyBN, 18);\n    const token0 = name.startsWith('BOMB') ? this.BOMB : this.BSHARE;\n    const isBomb = name.startsWith('BOMB');\n    const tokenAmountBN = await token0.balanceOf(lpToken.address);\n    const tokenAmount = getDisplayBalance(tokenAmountBN, 18);\n    const btcAmountBN = await this.BTC.balanceOf(lpToken.address);\n    const btcAmount = getDisplayBalance(btcAmountBN, 18);\n    const tokenAmountInOneLP = Number(tokenAmount) / Number(lpTokenSupply);\n    const ftmAmountInOneLP = Number(btcAmount) / Number(lpTokenSupply);\n    const lpTokenPrice = await this.getLPTokenPrice(lpToken, token0, isBomb);\n    const lpTokenPriceFixed = Number(lpTokenPrice).toFixed(2).toString();\n    const liquidity = (Number(lpTokenSupply) * Number(lpTokenPrice)).toFixed(2).toString();\n    return {\n      tokenAmount: tokenAmountInOneLP.toFixed(2).toString(),\n      ftmAmount: ftmAmountInOneLP.toFixed(5).toString(),\n      priceOfOne: lpTokenPriceFixed,\n      totalLiquidity: liquidity,\n      totalSupply: Number(lpTokenSupply).toFixed(2).toString()\n    };\n  }\n  /**\n   * Use this method to get price for Bomb\n   * @returns TokenStat for BBOND\n   * priceInBNB\n   * priceInDollars\n   * TotalSupply\n   * CirculatingSupply (always equal to total supply for bonds)\n   */\n\n\n  async getBondStat() {\n    const {\n      Treasury\n    } = this.contracts;\n    const bombStat = await this.getBombStat();\n    const bondBombRatioBN = await Treasury.getBondPremiumRate();\n    const modifier = bondBombRatioBN / 1e14 > 1 ? bondBombRatioBN / 1e14 : 1;\n    const bondPriceInBNB = (Number(bombStat.tokenInFtm) * modifier).toFixed(4);\n    const priceOfBBondInDollars = (Number(bombStat.priceInDollars) * modifier).toFixed(4);\n    const supply = await this.BBOND.displayedTotalSupply();\n    return {\n      tokenInFtm: bondPriceInBNB,\n      priceInDollars: priceOfBBondInDollars,\n      totalSupply: supply,\n      circulatingSupply: supply\n    };\n  }\n  /**\n   * @returns TokenStat for BSHARE\n   * priceInBNB\n   * priceInDollars\n   * TotalSupply\n   * CirculatingSupply (always equal to total supply for bonds)\n   */\n\n\n  async getShareStat() {\n    const {\n      BShareRewardPool\n    } = this.contracts;\n    const supply = await this.BSHARE.totalSupply();\n    const priceInBNB = await this.getTokenPriceFromPancakeswap(this.BSHARE);\n    const bombRewardPoolSupply = await this.BSHARE.balanceOf(BShareRewardPool.address);\n    const tShareCirculatingSupply = supply.sub(bombRewardPoolSupply);\n    const priceOfOneBNB = await this.getWBNBPriceFromPancakeswap();\n    const priceOfSharesInDollars = (Number(priceInBNB) * Number(priceOfOneBNB)).toFixed(2);\n    return {\n      tokenInFtm: priceInBNB,\n      priceInDollars: priceOfSharesInDollars,\n      totalSupply: getDisplayBalance(supply, this.BSHARE.decimal, 0),\n      circulatingSupply: getDisplayBalance(tShareCirculatingSupply, this.BSHARE.decimal, 0)\n    };\n  }\n\n  async getBombStatInEstimatedTWAP() {\n    const {\n      Oracle,\n      BombRewardPool\n    } = this.contracts;\n    const expectedPrice = await Oracle.twap(this.BOMB.address, ethers.utils.parseEther('10000'));\n    const supply = await this.BOMB.totalSupply();\n    const bombRewardPoolSupply = await this.BOMB.balanceOf(BombRewardPool.address);\n    const bombCirculatingSupply = supply.sub(bombRewardPoolSupply);\n    return {\n      tokenInFtm: getDisplayBalance(expectedPrice),\n      priceInDollars: getDisplayBalance(expectedPrice),\n      totalSupply: getDisplayBalance(supply, this.BOMB.decimal, 0),\n      circulatingSupply: getDisplayBalance(bombCirculatingSupply, this.BOMB.decimal, 0)\n    };\n  }\n\n  async getBombPriceInLastTWAP() {\n    const {\n      Treasury\n    } = this.contracts;\n    return Treasury.getBombUpdatedPrice();\n  } // async getBombPegTWAP(): Promise<any> {\n  //   const { Treasury } = this.contracts;\n  //   const updatedPrice = Treasury.getBombUpdatedPrice();\n  //   const updatedPrice2 = updatedPrice * 10000;\n  //   return updatedPrice2;\n  // }\n\n\n  async getBondsPurchasable() {\n    const {\n      Treasury\n    } = this.contracts; // const burnableBomb = (Number(Treasury.getBurnableBombLeft()) * 1000).toFixed(2).toString();\n\n    return Treasury.getBurnableBombLeft();\n  }\n\n  async getBombMaxiStats(poolId) {\n    const BombMaxi = await bombMaxi(poolId);\n    return {\n      totalShares: BombMaxi.data.pool.totalShares.toString(),\n      totalLiquidity: BombMaxi.data.pool.totalLiquidity.toString() // tokenAmount: tokenAmountInOneLP.toFixed(2).toString(),\n      // ftmAmount: ftmAmountInOneLP.toFixed(2).toString(),\n      // priceOfOne: lpTokenPriceFixed,\n      // totalLiquidity: liquidity,\n      // totalSupply: Number(lpTokenSupply).toFixed(2).toString(),\n\n    };\n  }\n  /**\n   * Calculates the TVL, APR and daily APR of a provided pool/bank\n   * @param bank\n   * @returns\n   */\n\n\n  async getPoolAPRs(bank) {\n    if (this.myAccount === undefined) return;\n    let depositToken = bank.depositToken; // if (depositToken.symbol === '80BOMB-20BTCB-LP' || depositToken.symbol === '80BSHARE-20WBNB-LP') {\n    //   const temp = 'TBD';\n    //   return {\n    //     dailyAPR: temp,\n    //     yearlyAPR: temp,\n    //     TVL: temp,\n    //   };\n    // }\n\n    const poolContract = this.contracts[bank.contract];\n    let depositTokenValue;\n\n    if (bank.depositTokenName === \"BBOND\") {\n      depositTokenValue = this.BOMB;\n    } else {\n      depositTokenValue = depositToken;\n    }\n\n    const depositTokenPrice = await this.getDepositTokenPriceInDollars(bank.depositTokenName, depositTokenValue);\n    const stakeInPool = await depositToken.balanceOf(bank.address);\n    const TVL = Number(depositTokenPrice) * Number(getDisplayBalance(stakeInPool, depositToken.decimal));\n    const stat = bank.earnTokenName === 'BOMB' ? await this.getBombStat() : await this.getShareStat();\n    const tokenPerSecond = await this.getTokenPerSecond(bank.earnTokenName, bank.contract, poolContract, bank.depositTokenName);\n    const tokenPerHour = tokenPerSecond.mul(60).mul(60);\n    const totalRewardPricePerYear = Number(stat.priceInDollars) * Number(getDisplayBalance(tokenPerHour.mul(24).mul(365)));\n    const totalRewardPricePerDay = Number(stat.priceInDollars) * Number(getDisplayBalance(tokenPerHour.mul(24)));\n    const totalStakingTokenInPool = Number(depositTokenPrice) * Number(getDisplayBalance(stakeInPool, depositToken.decimal));\n    const dailyAPR = totalRewardPricePerDay / totalStakingTokenInPool * 100;\n    const yearlyAPR = totalRewardPricePerYear / totalStakingTokenInPool * 100;\n    return {\n      dailyAPR: dailyAPR.toFixed(2).toString(),\n      yearlyAPR: yearlyAPR.toFixed(2).toString(),\n      TVL: TVL.toFixed(2).toString()\n    };\n  }\n\n  async getXbombAPR() {\n    if (this.myAccount === undefined) return;\n    const bombToken = this.BOMB;\n    const xbombToken = this.XBOMB;\n    const xbombExchange = await this.getXbombExchange();\n    const xbombPercent = await xbombExchange;\n    const xbombPercentTotal = Number(xbombPercent) / 1000000000000000000 * 100 - 100;\n    const depositTokenPrice = await this.getDepositTokenPriceInDollars(bombToken.symbol, bombToken);\n    const stakeInPool = await bombToken.balanceOf(xbombToken.address);\n    const TVL = Number(depositTokenPrice) * Number(getDisplayBalance(stakeInPool, bombToken.decimal));\n    const startDate = new Date('January 24, 2022');\n    const nowDate = new Date(Date.now());\n    const difference = nowDate.getTime() - startDate.getTime();\n    const days = difference / 60 / 60 / 24 / 1000;\n    const aprPerDay = xbombPercentTotal / days; // Determine days between now and a date\n    // const tokenPerHour = tokenPerSecond.mul(60).mul(60);\n    // const totalRewardPricePerYear =\n    //   Number(stat.priceInDollars) * Number(getDisplayBalance(tokenPerHour.mul(24).mul(365)));\n    // const totalRewardPricePerDay = Number(stat.priceInDollars) * Number(getDisplayBalance(tokenPerHour.mul(24)));\n    // const totalStakingTokenInPool =\n    //   Number(depositTokenPrice) * Number(getDisplayBalance(stakeInPool, depositToken.decimal));\n    // const dailyAPR = (totalRewardPricePerDay / totalStakingTokenInPool) * 100;\n    // const yearlyAPR = (totalRewardPricePerYear / totalStakingTokenInPool) * 100;\n\n    const dailyAPR = aprPerDay;\n    const yearlyAPR = aprPerDay * 365;\n    return {\n      dailyAPR: dailyAPR.toFixed(2).toString(),\n      yearlyAPR: yearlyAPR.toFixed(2).toString(),\n      TVL: TVL.toFixed(2).toString()\n    };\n  }\n  /**\n   * Method to return the amount of tokens the pool yields per second\n   * @param earnTokenName the name of the token that the pool is earning\n   * @param contractName the contract of the pool/bank\n   * @param poolContract the actual contract of the pool\n   * @returns\n   */\n\n\n  async getTokenPerSecond(earnTokenName, contractName, poolContract, depositTokenName) {\n    if (earnTokenName === 'BOMB') {\n      if (!contractName.endsWith('BombRewardPool')) {\n        const rewardPerSecond = await poolContract.tSharePerSecond();\n\n        if (depositTokenName === 'WBNB') {\n          return rewardPerSecond.mul(6000).div(11000).div(24);\n        } else if (depositTokenName === 'CAKE') {\n          return rewardPerSecond.mul(2500).div(11000).div(24);\n        } else if (depositTokenName === 'SUSD') {\n          return rewardPerSecond.mul(1000).div(11000).div(24);\n        } else if (depositTokenName === 'SVL') {\n          return rewardPerSecond.mul(1500).div(11000).div(24);\n        }\n\n        return rewardPerSecond.div(24);\n      }\n\n      const poolStartTime = await poolContract.poolStartTime();\n      const startDateTime = new Date(poolStartTime.toNumber() * 1000);\n      const FOUR_DAYS = 4 * 24 * 60 * 60 * 1000;\n\n      if (Date.now() - startDateTime.getTime() > FOUR_DAYS) {\n        return await poolContract.epochBombPerSecond(1);\n      }\n\n      return await poolContract.epochBombPerSecond(0);\n    }\n\n    const rewardPerSecond = await poolContract.tSharePerSecond();\n\n    if (depositTokenName.startsWith('BOMB-BTCB')) {\n      return rewardPerSecond.mul(400).div(1000);\n    } else if (depositTokenName.startsWith('BOMB-BSHARE')) {\n      return rewardPerSecond.mul(0).div(1000);\n    } else if (depositTokenName.startsWith('BOMB')) {\n      return rewardPerSecond.mul(0).div(1000);\n    } else if (depositTokenName.startsWith('BBOND')) {\n      return rewardPerSecond.mul(150).div(1000);\n    } else if (depositTokenName.startsWith('BUSM-BUSD')) {\n      return rewardPerSecond.mul(50).div(1000);\n    } else if (depositTokenName.startsWith('80BOMB')) {\n      return rewardPerSecond.mul(200).div(1000);\n    } else if (depositTokenName.startsWith('80BSHARE')) {\n      return rewardPerSecond.mul(50).div(1000);\n    } else {\n      return rewardPerSecond.mul(150).div(1000);\n    } // if (depositTokenName.startsWith('BOMB-BTCB')) {\n    //   return rewardPerSecond.mul(41650).div(10000);\n    // } else if (depositTokenName.startsWith('BOMB-BSHARE')) {\n    //   return rewardPerSecond.mul(0).div(119000);\n    // } else if (depositTokenName.startsWith('BOMB')) {\n    //   return rewardPerSecond.mul(59500).div(10000);\n    // } else {\n    //   return rewardPerSecond.mul(17850).div(10000);\n    // }\n\n  }\n  /**\n   * Method to calculate the tokenPrice of the deposited asset in a pool/bank\n   * If the deposited token is an LP it will find the price of its pieces\n   * @param tokenName\n   * @param pool\n   * @param token\n   * @returns\n   */\n\n\n  async getDepositTokenPriceInDollars(tokenName, token) {\n    let tokenPrice;\n    const priceOfOneFtmInDollars = await this.getWBNBPriceFromPancakeswap();\n\n    if (tokenName === 'WBNB') {\n      tokenPrice = priceOfOneFtmInDollars;\n    } else {\n      if (tokenName === 'BOMB-BTCB-LP') {\n        tokenPrice = await this.getLPTokenPrice(token, this.BOMB, true);\n      } else if (tokenName === 'BSHARE-BNB-LP') {\n        tokenPrice = await this.getLPTokenPrice(token, this.BSHARE, false);\n      } else if (tokenName === 'BOMB-BSHARE-LP') {\n        tokenPrice = await this.getLPTokenPrice(token, this.BOMB, true); // } else if (tokenName === 'BSHARE-BNB-APELP') {\n        //   tokenPrice = await this.getLPTokenPrice(token, this.BSHARE, false);\n      } else if (tokenName === 'BUSM-BUSD-LP') {\n        tokenPrice = await this.getBusdLPTokenPrice(token, this.BUSM, true);\n      } else if (tokenName === '80BOMB-20BTCB-LP') {\n        tokenPrice = await this.getMaxiLPTokenPrice('0xd6f52e8ab206e59a1e13b3d6c5b7f31e90ef46ef000200000000000000000028');\n      } else if (tokenName === '80BSHARE-20WBNB-LP') {\n        tokenPrice = await this.getMaxiLPTokenPrice('0x2c374ed1575e5c2c02c569f627299e902a1972cb000200000000000000000027');\n      } else if (tokenName === 'BBOND') {\n        tokenPrice = await this.getTokenPriceFromPancakeswap(this.BOMB);\n        tokenPrice = (Number(tokenPrice) * Number(priceOfOneFtmInDollars)).toString();\n      } else {\n        tokenPrice = await this.getTokenPriceFromPancakeswap(token);\n        tokenPrice = (Number(tokenPrice) * Number(priceOfOneFtmInDollars)).toString();\n      }\n    } //console.log({ tokenPrice });\n\n\n    return tokenPrice;\n  } //===================================================================\n  //===================== GET ASSET STATS =============================\n  //=========================== END ===================================\n  //===================================================================\n\n\n  async getCurrentEpoch() {\n    const {\n      Treasury\n    } = this.contracts;\n    return Treasury.epoch();\n  }\n\n  async getBondOraclePriceInLastTWAP() {\n    const {\n      Treasury\n    } = this.contracts;\n    return Treasury.getBondPremiumRate();\n  }\n  /**\n   * Buy bonds with cash.\n   * @param amount amount of cash to purchase bonds with.\n   */\n\n\n  async buyBonds(amount) {\n    const {\n      Treasury\n    } = this.contracts;\n    const treasuryBombPrice = await Treasury.getBombPrice();\n    return await Treasury.buyBonds(decimalToBalance(amount), treasuryBombPrice);\n  }\n  /**\n   * Redeem bonds for cash.\n   * @param amount amount of bonds to redeem.\n   */\n\n\n  async redeemBonds(amount) {\n    const {\n      Treasury\n    } = this.contracts;\n    const priceForBomb = await Treasury.getBombPrice();\n    return await Treasury.redeemBonds(decimalToBalance(amount), priceForBomb);\n  }\n\n  async getTotalValueLocked() {\n    let totalValue = 0;\n\n    for (const bankInfo of Object.values(bankDefinitions)) {\n      const pool = this.contracts[bankInfo.contract];\n      const token = this.externalTokens[bankInfo.depositTokenName];\n      const tokenPrice = await this.getDepositTokenPriceInDollars(bankInfo.depositTokenName, token);\n      const tokenAmountInPool = await token.balanceOf(pool.address);\n      const value = Number(getDisplayBalance(tokenAmountInPool, token.decimal)) * Number(tokenPrice);\n      const poolValue = Number.isNaN(value) ? 0 : value;\n      totalValue += poolValue;\n    }\n\n    const BSHAREPrice = (await this.getShareStat()).priceInDollars;\n    const BOMBPrice = (await this.getBombStat()).priceInDollars;\n    const boardroomtShareBalanceOf = await this.BSHARE.balanceOf(this.currentBoardroom().address);\n    const bombStakeBalanceOf = await this.BOMB.balanceOf(this.XBOMB.address);\n    const boardroomTVL = Number(getDisplayBalance(boardroomtShareBalanceOf, this.BSHARE.decimal)) * Number(BSHAREPrice);\n    const bombTVL = Number(getDisplayBalance(bombStakeBalanceOf, this.BOMB.decimal)) * Number(BOMBPrice);\n    return totalValue + boardroomTVL + bombTVL;\n  }\n  /**\n   * Calculates the price of an LP token\n   * Reference https://github.com/DefiDebauchery/discordpricebot/blob/4da3cdb57016df108ad2d0bb0c91cd8dd5f9d834/pricebot/pricebot.py#L150\n   * @param lpToken the token under calculation\n   * @param token the token pair used as reference (the other one would be BNB in most cases)\n   * @param isBomb sanity check for usage of bomb token or tShare\n   * @returns price of the LP token\n   */\n\n\n  async getLPTokenPrice(lpToken, token, isBomb) {\n    const totalSupply = getFullDisplayBalance(await lpToken.totalSupply(), lpToken.decimal); //Get amount of tokenA\n\n    const tokenSupply = getFullDisplayBalance(await token.balanceOf(lpToken.address), token.decimal);\n    const stat = isBomb === true ? await this.getBombStat() : await this.getShareStat();\n    const priceOfToken = stat.priceInDollars;\n    const tokenInLP = Number(tokenSupply) / Number(totalSupply);\n    const tokenPrice = (Number(priceOfToken) * tokenInLP * 2 //We multiply by 2 since half the price of the lp token is the price of each piece of the pair. So twice gives the total\n    ).toString();\n    return tokenPrice;\n  }\n  /**\n   * Calculates the price of an LP token\n   * Reference https://github.com/DefiDebauchery/discordpricebot/blob/4da3cdb57016df108ad2d0bb0c91cd8dd5f9d834/pricebot/pricebot.py#L150\n   * @param lpToken the token under calculation\n   * @param token the token pair used as reference (the other one would be BNB in most cases)\n   * @param isBomb sanity check for usage of bomb token or tShare\n   * @returns price of the LP token\n   */\n\n\n  async getBusdLPTokenPrice(lpToken, token, isBomb) {\n    const totalSupply = getFullDisplayBalance(await lpToken.totalSupply(), lpToken.decimal); //Get amount of tokenA\n\n    const tokenSupply = getFullDisplayBalance(await token.balanceOf(lpToken.address), token.decimal); // const stat = isBomb === true ? await this.getBombStat() : await this.getShareStat();\n\n    const priceToken = await this.getTokenPriceFromPancakeswapBUSD(this.BUSM);\n    const priceOfToken = Number(priceToken);\n    const tokenInLP = Number(tokenSupply) / Number(totalSupply);\n    const tokenPrice = (Number(priceOfToken) * tokenInLP * 2 //We multiply by 2 since half the price of the lp token is the price of each piece of the pair. So twice gives the total\n    ).toString();\n    return tokenPrice;\n  }\n\n  async getMaxiLPTokenPrice(maxiPool) {\n    const bombmaxi = await this.getBombMaxiStats(maxiPool);\n    const totalShares = await bombmaxi.totalShares; //Get amount of tokenA\n\n    const totalLiquidity = await bombmaxi.totalLiquidity; // const stat = isBomb === true ? await this.getBombStat() : await this.getShareStat();\n\n    const tokenInLP = Number(totalLiquidity) / Number(totalShares);\n    const tokenPrice = tokenInLP //We multiply by 2 since half the price of the lp token is the price of each piece of the pair. So twice gives the total\n    .toString();\n    return tokenPrice;\n  }\n\n  async earnedFromBank(poolName, earnTokenName, poolId) {\n    let account = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : this.myAccount;\n    const pool = this.contracts[poolName];\n\n    try {\n      if (earnTokenName === 'BOMB') {\n        return await pool.pendingBOMB(poolId, account);\n      } else {\n        return await pool.pendingShare(poolId, account);\n      }\n    } catch (err) {\n      console.error(`Failed to call pendingShare() on pool ${pool.address}: ${err.stack}`);\n      return BigNumber.from(0);\n    }\n  }\n\n  async stakedBalanceOnBank(poolName, poolId) {\n    let account = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.myAccount;\n    const pool = this.contracts[poolName];\n\n    try {\n      let userInfo = await pool.userInfo(poolId, account);\n      return await userInfo.amount;\n    } catch (err) {\n      console.error(`Failed to call userInfo() on pool ${pool.address}: ${err.stack}`);\n      return BigNumber.from(0);\n    }\n  }\n  /**\n   * Deposits token to given pool.\n   * @param poolName A name of pool contract.\n   * @param amount Number of tokens with decimals applied. (e.g. 1.45 DAI * 10^18)\n   * @returns {string} Transaction hash\n   */\n\n\n  async stake(poolName, poolId, amount) {\n    const pool = this.contracts[poolName];\n    return await pool.deposit(poolId, amount);\n  }\n  /**\n   * Withdraws token from given pool.\n   * @param poolName A name of pool contract.\n   * @param amount Number of tokens with decimals applied. (e.g. 1.45 DAI * 10^18)\n   * @returns {string} Transaction hash\n   */\n\n\n  async unstake(poolName, poolId, amount) {\n    const pool = this.contracts[poolName];\n    return await pool.withdraw(poolId, amount);\n  }\n  /**\n   * Transfers earned token reward from given pool to my account.\n   */\n\n\n  async harvest(poolName, poolId) {\n    const pool = this.contracts[poolName]; //By passing 0 as the amount, we are asking the contract to only redeem the reward and not the currently staked token\n\n    return await pool.withdraw(poolId, 0);\n  }\n  /**\n   * Harvests and withdraws deposited tokens from the pool.\n   */\n\n\n  async exit(poolName, poolId) {\n    let account = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.myAccount;\n    const pool = this.contracts[poolName];\n    let userInfo = await pool.userInfo(poolId, account);\n    return await pool.withdraw(poolId, userInfo.amount);\n  }\n\n  async fetchBoardroomVersionOfUser() {\n    return 'latest';\n  }\n\n  currentBoardroom() {\n    if (!this.boardroomVersionOfUser) {//throw new Error('you must unlock the wallet to continue.');\n    }\n\n    return this.contracts.Boardroom;\n  }\n\n  isOldBoardroomMember() {\n    return this.boardroomVersionOfUser !== 'latest';\n  }\n\n  async getTokenPriceFromPancakeswap(tokenContract) {\n    const ready = await this.provider.ready;\n    if (!ready) return; //const { chainId } = this.config;\n\n    const {\n      WBNB\n    } = this.config.externalTokens;\n    const wftm = new Token(56, WBNB[0], WBNB[1], 'WBNB');\n    const token = new Token(56, tokenContract.address, tokenContract.decimal, tokenContract.symbol);\n\n    try {\n      const wftmToToken = await Fetcher.fetchPairData(wftm, token, this.provider);\n      const priceInBUSD = new Route([wftmToToken], token);\n      return priceInBUSD.midPrice.toFixed(4);\n    } catch (err) {\n      console.error(`Failed to fetch token price of ${tokenContract.symbol}: ${err}`);\n    }\n  }\n\n  async getTokenPriceFromPancakeswapBUSD(tokenContract) {\n    const ready = await this.provider.ready;\n    if (!ready) return; //const { chainId } = this.config;\n\n    const {\n      BUSD\n    } = this.config.externalTokens;\n    const wftm = new Token(56, BUSD[0], BUSD[1], 'BUSD');\n    const token = new Token(56, tokenContract.address, tokenContract.decimal, tokenContract.symbol);\n\n    try {\n      const wftmToToken = await Fetcher.fetchPairData(wftm, token, this.provider);\n      const priceInBUSD = new Route([wftmToToken], token);\n      return priceInBUSD.midPrice.toFixed(4);\n    } catch (err) {\n      console.error(`Failed to fetch token price of ${tokenContract.symbol}: ${err}`);\n    }\n  }\n\n  async getTokenPriceFromPancakeswapBTC(tokenContract) {\n    const ready = await this.provider.ready;\n    if (!ready) return; //const { chainId } = this.config;\n    // const {WBNB} = this.config.externalTokens;\n    // const wbnb = new Token(56, WBNB[0], WBNB[1]);\n\n    const btcb = new Token(56, this.BTC.address, this.BTC.decimal, 'BTCB', 'BTCB');\n    const token = new Token(56, tokenContract.address, tokenContract.decimal, tokenContract.symbol);\n\n    try {\n      const wftmToToken = await Fetcher.fetchPairData(btcb, token, this.provider);\n      const priceInBUSD = new Route([wftmToToken], token); //   console.log('priceInBUSDBTC', priceInBUSD.midPrice.toFixed(12));\n\n      const priceForPeg = Number(priceInBUSD.midPrice.toFixed(12)) * 10000;\n      return priceForPeg.toFixed(4);\n    } catch (err) {\n      console.error(`Failed to fetch token price of ${tokenContract.symbol}: ${err}`);\n    }\n  }\n\n  async getTokenPriceFromPancakeswapBOMBUSD() {\n    const ready = await this.provider.ready;\n    if (!ready) return; //const { chainId } = this.config;\n    //const {WBNB} = this.config.externalTokens;\n    //  const wbnb = new Token(56, WBNB[0], WBNB[1]);\n\n    const btcb = new Token(56, this.BTC.address, this.BTC.decimal, 'BTCB', 'BTCB');\n    const token = new Token(56, this.BOMB.address, this.BOMB.decimal, this.BOMB.symbol);\n\n    try {\n      const wftmToToken = await Fetcher.fetchPairData(btcb, token, this.provider);\n      const priceInBUSD = new Route([wftmToToken], token); // console.log('test', priceInBUSD.midPrice.toFixed(12));\n\n      const priceForPeg = Number(priceInBUSD.midPrice.toFixed(12)) * 10000;\n      return priceForPeg.toFixed(4);\n    } catch (err) {\n      console.error(`Failed to fetch token price of ${this.BOMB.symbol}: ${err}`);\n    }\n  } // async getTokenPriceFromSpiritswap(tokenContract: ERC20): Promise<string> {\n  //   const ready = await this.provider.ready;\n  //   if (!ready) return;\n  //   const { chainId } = this.config;\n  //   const { WBNB } = this.externalTokens;\n  //   const wftm = new TokenSpirit(chainId, WBNB.address, WBNB.decimal);\n  //   const token = new TokenSpirit(chainId, tokenContract.address, tokenContract.decimal, tokenContract.symbol);\n  //   try {\n  //     const wftmToToken = await FetcherSpirit.fetchPairData(wftm, token, this.provider);\n  //     const liquidityToken = wftmToToken.liquidityToken;\n  //     let ftmBalanceInLP = await WBNB.balanceOf(liquidityToken.address);\n  //     let ftmAmount = Number(getFullDisplayBalance(ftmBalanceInLP, WBNB.decimal));\n  //     let shibaBalanceInLP = await tokenContract.balanceOf(liquidityToken.address);\n  //     let shibaAmount = Number(getFullDisplayBalance(shibaBalanceInLP, tokenContract.decimal));\n  //     const priceOfOneFtmInDollars = await this.getWBNBPriceFromPancakeswap();\n  //     let priceOfShiba = (ftmAmount / shibaAmount) * Number(priceOfOneFtmInDollars);\n  //     return priceOfShiba.toString();\n  //   } catch (err) {\n  //     console.error(`Failed to fetch token price of ${tokenContract.symbol}: ${err}`);\n  //   }\n  // }\n\n\n  async getWBNBPriceFromPancakeswap() {\n    const ready = await this.provider.ready;\n    if (!ready) return;\n    const {\n      WBNB,\n      FUSDT\n    } = this.externalTokens;\n\n    try {\n      const fusdt_wftm_lp_pair = this.externalTokens['USDT-BNB-LP'];\n      let ftm_amount_BN = await WBNB.balanceOf(fusdt_wftm_lp_pair.address);\n      let ftm_amount = Number(getFullDisplayBalance(ftm_amount_BN, WBNB.decimal));\n      let fusdt_amount_BN = await FUSDT.balanceOf(fusdt_wftm_lp_pair.address);\n      let fusdt_amount = Number(getFullDisplayBalance(fusdt_amount_BN, FUSDT.decimal));\n      return (fusdt_amount / ftm_amount).toString();\n    } catch (err) {\n      console.error(`Failed to fetch token price of WBNB: ${err}`);\n    }\n  }\n\n  async getBTCBPriceFromPancakeswap() {\n    const ready = await this.provider.ready;\n    if (!ready) return;\n    const {\n      BTCB\n    } = this.externalTokens;\n\n    try {\n      const btcPriceInBNB = await this.getTokenPriceFromPancakeswap(BTCB);\n      const wbnbPrice = await this.getWBNBPriceFromPancakeswap();\n      const btcprice = (Number(btcPriceInBNB) * Number(wbnbPrice)).toFixed(2).toString(); //console.log('btcprice', btcprice);\n\n      return btcprice;\n    } catch (err) {\n      console.error(`Failed to fetch token price of BTCB: ${err}`);\n    }\n  } // async getBTCBPriceFromPancakeswap(): Promise<string> {\n  //   const ready = await this.provider.ready;\n  //   if (!ready) return;\n  //   const { BTCB, FUSDT } = this.externalTokens;\n  //   try {\n  //     const fusdt_btcb_lp_pair = this.externalTokens['USDT-BTCB-LP'];\n  //     let ftm_amount_BN = await BTCB.balanceOf(fusdt_btcb_lp_pair.address);\n  //     let ftm_amount = Number(getFullDisplayBalance(ftm_amount_BN, BTCB.decimal));\n  //     let fusdt_amount_BN = await FUSDT.balanceOf(fusdt_btcb_lp_pair.address);\n  //     let fusdt_amount = Number(getFullDisplayBalance(fusdt_amount_BN, FUSDT.decimal));\n  //     console.log('BTCB price', (fusdt_amount / ftm_amount).toString());\n  //     return (fusdt_amount / ftm_amount).toString();\n  //     console.log('BTCB price');\n  //   } catch (err) {\n  //     console.error(`Failed to fetch token price of BTCB: ${err}`);\n  //   }\n  // }\n  //===================================================================\n  //===================================================================\n  //===================== MASONRY METHODS =============================\n  //===================================================================\n  //===================================================================\n\n\n  async getBoardroomAPR() {\n    const Boardroom = this.currentBoardroom();\n    const latestSnapshotIndex = await Boardroom.latestSnapshotIndex();\n    const lastHistory = await Boardroom.boardroomHistory(latestSnapshotIndex);\n    const lastRewardsReceived = lastHistory[1];\n    const BSHAREPrice = (await this.getShareStat()).priceInDollars;\n    const BOMBPrice = (await this.getBombStat()).priceInDollars;\n    const epochRewardsPerShare = lastRewardsReceived / 1e18; //Mgod formula\n\n    const amountOfRewardsPerDay = epochRewardsPerShare * Number(BOMBPrice) * 4;\n    const boardroomtShareBalanceOf = await this.BSHARE.balanceOf(Boardroom.address);\n    const boardroomTVL = Number(getDisplayBalance(boardroomtShareBalanceOf, this.BSHARE.decimal)) * Number(BSHAREPrice);\n    const realAPR = amountOfRewardsPerDay * 100 / boardroomTVL * 365;\n    return realAPR;\n  }\n\n  async getBombStakeAPR() {\n    const Boardroom = this.currentBoardroom();\n    const latestSnapshotIndex = await Boardroom.latestSnapshotIndex();\n    const lastHistory = await Boardroom.boardroomHistory(latestSnapshotIndex);\n    const lastRewardsReceived = lastHistory[1];\n    const BOMBPrice = (await this.getBombStat()).priceInDollars;\n    const epochRewardsPerShare = lastRewardsReceived / 1e18; //Mgod formula\n\n    const amountOfRewardsPerDay = epochRewardsPerShare * Number(BOMBPrice) * 4;\n    const xBombBombBalanceOf = await this.BOMB.balanceOf(this.XBOMB.address);\n    const bombTVL = Number(getDisplayBalance(xBombBombBalanceOf, this.XBOMB.decimal)) * Number(BOMBPrice);\n    const realAPR = amountOfRewardsPerDay * 100 * 0.2 / bombTVL * 365;\n    return realAPR;\n  }\n  /**\n   * Checks if the user is allowed to retrieve their reward from the Boardroom\n   * @returns true if user can withdraw reward, false if they can't\n   */\n\n\n  async canUserClaimRewardFromBoardroom() {\n    const Boardroom = this.currentBoardroom();\n    return await Boardroom.canClaimReward(this.myAccount);\n  }\n  /**\n   * Checks if the user is allowed to retrieve their reward from the Boardroom\n   * @returns true if user can withdraw reward, false if they can't\n   */\n\n\n  async canUserUnstakeFromBoardroom() {\n    const Boardroom = this.currentBoardroom();\n    const canWithdraw = await Boardroom.canWithdraw(this.myAccount);\n    const stakedAmount = await this.getStakedSharesOnBoardroom();\n    const notStaked = Number(getDisplayBalance(stakedAmount, this.BSHARE.decimal)) === 0;\n    const result = notStaked ? true : canWithdraw;\n    return result;\n  }\n\n  async timeUntilClaimRewardFromBoardroom() {\n    // const Boardroom = this.currentBoardroom();\n    // const mason = await Boardroom.masons(this.myAccount);\n    return BigNumber.from(0);\n  }\n\n  async getTotalStakedInBoardroom() {\n    const Boardroom = this.currentBoardroom();\n    return await Boardroom.totalSupply();\n  }\n\n  async stakeShareToBoardroom(amount) {\n    if (this.isOldBoardroomMember()) {\n      throw new Error(\"you're using old boardroom. please withdraw and deposit the BSHARE again.\");\n    }\n\n    const Boardroom = this.currentBoardroom();\n    return await Boardroom.stake(decimalToBalance(amount));\n  }\n\n  async stakeToBomb(amount) {\n    const Xbomb = this.contracts.xBOMB;\n    return await Xbomb.enter(decimalToBalance(amount));\n  }\n\n  async redeemFromBomb(amount) {\n    const BombRouter = this.contracts.BombRouter;\n    const expiry = new Date(Date.now() + 2880);\n    return await BombRouter.redeem(this.BBOMB_BOMB.address, decimalToBalance(amount), this.myAccount, expiry.getTime(), '0x');\n  }\n\n  async redeemFromBtcb(amount) {\n    const BombRouter = this.contracts.BombRouter;\n    const expiry = new Date(Date.now() + 2880);\n    return await BombRouter.redeem(this.BBOMB_BTCB.address, decimalToBalance(amount), this.myAccount, expiry.getTime(), '0x');\n  }\n\n  async supplyToBtcb(amount) {\n    const BombRouter = this.contracts.BombRouter;\n    const expiry = new Date(Date.now() + 2880);\n    return await BombRouter.mint(this.BBOMB_BTCB.address, decimalToBalance(amount), this.myAccount, expiry.getTime());\n  }\n\n  async supplyToBomb(amount) {\n    const BombRouter = this.contracts.BombRouter;\n    const expiry = new Date(Date.now() + 2880);\n    return await BombRouter.mint(this.BBOMB_BOMB.address, decimalToBalance(amount), this.myAccount, expiry.getTime());\n  }\n\n  async getStakedSharesOnBoardroom() {\n    const Boardroom = this.currentBoardroom();\n\n    if (this.boardroomVersionOfUser === 'v1') {\n      return await Boardroom.getShareOf(this.myAccount);\n    }\n\n    return await Boardroom.balanceOf(this.myAccount);\n  }\n\n  async getStakedBomb() {\n    const Xbomb = this.contracts.xBOMB;\n    return await Xbomb.balanceOf(this.myAccount);\n  }\n\n  async getTotalStakedBomb() {\n    const Xbomb = this.contracts.xBOMB;\n    const bomb = this.BOMB;\n    return await bomb.balanceOf(Xbomb.address);\n  }\n\n  async getTotalSuppliedBomb() {\n    const bbombBomb = this.BOMB_BORROWABLE; // const bomb = this.BOMB;\n\n    const totalBomb = await bbombBomb.totalBalance(); //  const borrowBomb = await bbombBomb.totalBorrows();\n    // const totalSupplied = totalBomb + borrowBomb;\n\n    return totalBomb;\n  }\n\n  async getTotalSuppliedBtcb() {\n    const bbombBomb = this.BTCB_BORROWABLE; // const bomb = this.BOMB;\n\n    const totalBtcb = await bbombBomb.totalBalance(); //const borrowBtcb = await bbombBomb.totalBorrows();\n    //  const totalSupplied = totalBtcb + borrowBtcb;\n\n    return totalBtcb;\n  }\n\n  async getXbombExchange() {\n    const Xbomb = this.contracts.xBOMB;\n    const XbombExchange = await Xbomb.getExchangeRate();\n    const xBombPerBomb = parseFloat(XbombExchange) / 1000000000000000000;\n    const xBombRate = xBombPerBomb.toString();\n    return parseUnits(xBombRate, 18);\n  }\n\n  async withdrawFromBomb(amount) {\n    const Xbomb = this.contracts.xBOMB;\n    return await Xbomb.leave(decimalToBalance(amount));\n  }\n\n  async getEarningsOnBoardroom() {\n    const Boardroom = this.currentBoardroom();\n\n    if (this.boardroomVersionOfUser === 'v1') {\n      return await Boardroom.getCashEarningsOf(this.myAccount);\n    }\n\n    return await Boardroom.earned(this.myAccount);\n  }\n\n  async withdrawShareFromBoardroom(amount) {\n    const Boardroom = this.currentBoardroom();\n    return await Boardroom.withdraw(decimalToBalance(amount));\n  }\n\n  async harvestCashFromBoardroom() {\n    const Boardroom = this.currentBoardroom();\n\n    if (this.boardroomVersionOfUser === 'v1') {\n      return await Boardroom.claimDividends();\n    }\n\n    return await Boardroom.claimReward();\n  }\n\n  async exitFromBoardroom() {\n    const Boardroom = this.currentBoardroom();\n    return await Boardroom.exit();\n  }\n\n  async getTreasuryNextAllocationTime() {\n    const {\n      Treasury\n    } = this.contracts;\n    const nextEpochTimestamp = await Treasury.nextEpochPoint();\n    const nextAllocation = new Date(nextEpochTimestamp.mul(1000).toNumber());\n    const prevAllocation = new Date(Date.now());\n    return {\n      from: prevAllocation,\n      to: nextAllocation\n    };\n  }\n  /**\n   * This method calculates and returns in a from to to format\n   * the period the user needs to wait before being allowed to claim\n   * their reward from the boardroom\n   * @returns Promise<AllocationTime>\n   */\n\n\n  async getUserClaimRewardTime() {\n    const {\n      Boardroom,\n      Treasury\n    } = this.contracts;\n    const nextEpochTimestamp = await Boardroom.nextEpochPoint(); //in unix timestamp\n\n    const currentEpoch = await Boardroom.epoch();\n    const mason = await Boardroom.members(this.myAccount);\n    const startTimeEpoch = mason.epochTimerStart;\n    const period = await Treasury.PERIOD();\n    const periodInHours = period / 60 / 60; // 6 hours, period is displayed in seconds which is 21600\n\n    const rewardLockupEpochs = await Boardroom.rewardLockupEpochs();\n    const targetEpochForClaimUnlock = Number(startTimeEpoch) + Number(rewardLockupEpochs);\n    const fromDate = new Date(Date.now());\n\n    if (targetEpochForClaimUnlock - currentEpoch <= 0) {\n      return {\n        from: fromDate,\n        to: fromDate\n      };\n    } else if (targetEpochForClaimUnlock - currentEpoch === 1) {\n      const toDate = new Date(nextEpochTimestamp * 1000);\n      return {\n        from: fromDate,\n        to: toDate\n      };\n    } else {\n      const toDate = new Date(nextEpochTimestamp * 1000);\n      const delta = targetEpochForClaimUnlock - currentEpoch - 1;\n      const endDate = moment(toDate).add(delta * periodInHours, 'hours').toDate();\n      return {\n        from: fromDate,\n        to: endDate\n      };\n    }\n  }\n  /**\n   * This method calculates and returns in a from to to format\n   * the period the user needs to wait before being allowed to unstake\n   * from the boardroom\n   * @returns Promise<AllocationTime>\n   */\n\n\n  async getUserUnstakeTime() {\n    const {\n      Boardroom,\n      Treasury\n    } = this.contracts;\n    const nextEpochTimestamp = await Boardroom.nextEpochPoint();\n    const currentEpoch = await Boardroom.epoch();\n    const mason = await Boardroom.members(this.myAccount);\n    const startTimeEpoch = mason.epochTimerStart;\n    const period = await Treasury.PERIOD();\n    const PeriodInHours = period / 60 / 60;\n    const withdrawLockupEpochs = await Boardroom.withdrawLockupEpochs();\n    const fromDate = new Date(Date.now());\n    const targetEpochForClaimUnlock = Number(startTimeEpoch) + Number(withdrawLockupEpochs);\n    const stakedAmount = await this.getStakedSharesOnBoardroom();\n\n    if (currentEpoch <= targetEpochForClaimUnlock && Number(stakedAmount) === 0) {\n      return {\n        from: fromDate,\n        to: fromDate\n      };\n    } else if (targetEpochForClaimUnlock - currentEpoch === 1) {\n      const toDate = new Date(nextEpochTimestamp * 1000);\n      return {\n        from: fromDate,\n        to: toDate\n      };\n    } else {\n      const toDate = new Date(nextEpochTimestamp * 1000);\n      const delta = targetEpochForClaimUnlock - Number(currentEpoch) - 1;\n      const endDate = moment(toDate).add(delta * PeriodInHours, 'hours').toDate();\n      return {\n        from: fromDate,\n        to: endDate\n      };\n    }\n  }\n\n  async watchAssetInMetamask(assetName) {\n    const {\n      ethereum\n    } = window;\n\n    if (ethereum && ethereum.networkVersion === config.chainId.toString()) {\n      let asset;\n      let assetUrl;\n\n      if (assetName === 'BOMB') {\n        asset = this.BOMB;\n        assetUrl = 'https://raw.githubusercontent.com/bombmoney/bomb-assets/master/bomb-512.png';\n      } else if (assetName === 'BSHARE') {\n        asset = this.BSHARE;\n        assetUrl = 'https://raw.githubusercontent.com/bombmoney/bomb-assets/master/bshare-512.png';\n      } else if (assetName === 'BBOND') {\n        asset = this.BBOND;\n        assetUrl = 'https://raw.githubusercontent.com/bombmoney/bomb-assets/master/bbond-512.png';\n      } else if (assetName === 'XBOMB') {\n        asset = this.XBOMB;\n        assetUrl = 'https://raw.githubusercontent.com/bombmoney/bomb-assets/master/xbomb-512.png';\n      } else if (assetName === 'BTCB') {\n        asset = this.BTC;\n        assetUrl = 'https://bscscan.com/token/images/btcb_32.png';\n      }\n\n      await ethereum.request({\n        method: 'wallet_watchAsset',\n        params: {\n          type: 'ERC20',\n          options: {\n            address: asset.address,\n            symbol: asset.symbol,\n            decimals: 18,\n            image: assetUrl\n          }\n        }\n      });\n    }\n\n    return true;\n  }\n\n  async provideBombFtmLP(ftmAmount, bombAmount) {\n    const {\n      TaxOffice\n    } = this.contracts;\n    let overrides = {\n      value: parseUnits(ftmAmount, 18)\n    };\n    return await TaxOffice.addLiquidityETHTaxFree(bombAmount, bombAmount.mul(992).div(1000), parseUnits(ftmAmount, 18).mul(992).div(1000), overrides);\n  }\n\n  async quoteFromSpooky(tokenAmount, tokenName) {\n    const {\n      SpookyRouter\n    } = this.contracts;\n    const {\n      _reserve0,\n      _reserve1\n    } = await this.BOMBBTCB_LP.getReserves();\n    let quote;\n\n    if (tokenName === 'BOMB') {\n      quote = await SpookyRouter.quote(parseUnits(tokenAmount), _reserve0, _reserve1);\n    } else {\n      quote = await SpookyRouter.quote(parseUnits(tokenAmount), _reserve1, _reserve0);\n    }\n\n    return (quote / 1e18).toString();\n  }\n  /**\n   * @returns an array of the regulation events till the most up to date epoch\n   */\n\n\n  async listenForRegulationsEvents() {\n    const {\n      Treasury\n    } = this.contracts;\n    const treasuryDaoFundedFilter = Treasury.filters.DaoFundFunded();\n    const treasuryDevFundedFilter = Treasury.filters.DevFundFunded();\n    const treasuryBoardroomFundedFilter = Treasury.filters.BoardroomFunded();\n    const boughtBondsFilter = Treasury.filters.BoughtBonds();\n    const redeemBondsFilter = Treasury.filters.RedeemedBonds();\n    let epochBlocksRanges = [];\n    let boardroomFundEvents = await Treasury.queryFilter(treasuryBoardroomFundedFilter);\n    var events = [];\n    boardroomFundEvents.forEach(function callback(value, index) {\n      events.push({\n        epoch: index + 1\n      });\n      events[index].boardroomFund = getDisplayBalance(value.args[1]);\n\n      if (index === 0) {\n        epochBlocksRanges.push({\n          index: index,\n          startBlock: value.blockNumber,\n          boughBonds: 0,\n          redeemedBonds: 0\n        });\n      }\n\n      if (index > 0) {\n        epochBlocksRanges.push({\n          index: index,\n          startBlock: value.blockNumber,\n          boughBonds: 0,\n          redeemedBonds: 0\n        });\n        epochBlocksRanges[index - 1].endBlock = value.blockNumber;\n      }\n    });\n    epochBlocksRanges.forEach(async (value, index) => {\n      events[index].bondsBought = await this.getBondsWithFilterForPeriod(boughtBondsFilter, value.startBlock, value.endBlock);\n      events[index].bondsRedeemed = await this.getBondsWithFilterForPeriod(redeemBondsFilter, value.startBlock, value.endBlock);\n    });\n    let DEVFundEvents = await Treasury.queryFilter(treasuryDevFundedFilter);\n    DEVFundEvents.forEach(function callback(value, index) {\n      events[index].devFund = getDisplayBalance(value.args[1]);\n    });\n    let DAOFundEvents = await Treasury.queryFilter(treasuryDaoFundedFilter);\n    DAOFundEvents.forEach(function callback(value, index) {\n      events[index].daoFund = getDisplayBalance(value.args[1]);\n    });\n    return events;\n  }\n  /**\n   * Helper method\n   * @param filter applied on the query to the treasury events\n   * @param from block number\n   * @param to block number\n   * @returns the amount of bonds events emitted based on the filter provided during a specific period\n   */\n\n\n  async getBondsWithFilterForPeriod(filter, from, to) {\n    const {\n      Treasury\n    } = this.contracts;\n    const bondsAmount = await Treasury.queryFilter(filter, from, to);\n    return bondsAmount.length;\n  }\n\n  async estimateZapIn(tokenName, lpName, amount) {\n    const {\n      zapper\n    } = this.contracts;\n    const lpToken = this.externalTokens[lpName];\n    let estimate;\n\n    if (tokenName === BNB_TICKER) {\n      estimate = await zapper.estimateZapIn(lpToken.address, SPOOKY_ROUTER_ADDR, parseUnits(amount, 18));\n    } else {\n      const token = tokenName === BOMB_TICKER ? this.BOMB : this.BSHARE;\n      estimate = await zapper.estimateZapInToken(token.address, lpToken.address, SPOOKY_ROUTER_ADDR, parseUnits(amount, 18));\n    }\n\n    return [estimate[0] / 1e18, estimate[1] / 1e18];\n  }\n\n  async zapIn(tokenName, lpName, amount) {\n    const {\n      zapper\n    } = this.contracts;\n    const lpToken = this.externalTokens[lpName];\n\n    if (tokenName === BNB_TICKER) {\n      let overrides = {\n        value: parseUnits(amount, 18)\n      };\n      return await zapper.zapIn(lpToken.address, SPOOKY_ROUTER_ADDR, this.myAccount, overrides);\n    } else {\n      const token = tokenName === BOMB_TICKER ? this.BOMB : this.BSHARE;\n      return await zapper.zapInToken(token.address, parseUnits(amount, 18), lpToken.address, SPOOKY_ROUTER_ADDR, this.myAccount);\n    }\n  }\n\n  async swapBBondToBShare(bbondAmount) {\n    const {\n      BShareSwapper\n    } = this.contracts;\n    return await BShareSwapper.swapBBondToBShare(bbondAmount);\n  }\n\n  async estimateAmountOfBShare(bbondAmount) {\n    const {\n      BShareSwapper\n    } = this.contracts;\n\n    try {\n      const estimateBN = await BShareSwapper.estimateAmountOfBShare(parseUnits(bbondAmount, 18));\n      return getDisplayBalance(estimateBN, 18, 6);\n    } catch (err) {\n      console.error(`Failed to fetch estimate bshare amount: ${err}`);\n    }\n  }\n\n  async getBShareSwapperStat(address) {\n    const {\n      BShareSwapper\n    } = this.contracts;\n    const bshareBalanceBN = await BShareSwapper.getBShareBalance();\n    const bbondBalanceBN = await BShareSwapper.getBBondBalance(address); // const bombPriceBN = await BShareSwapper.getBombPrice();\n    // const bsharePriceBN = await BShareSwapper.getBSharePrice();\n\n    const rateBSharePerBombBN = await BShareSwapper.getBShareAmountPerBomb();\n    const bshareBalance = getDisplayBalance(bshareBalanceBN, 18, 5);\n    const bbondBalance = getDisplayBalance(bbondBalanceBN, 18, 5);\n    return {\n      bshareBalance: bshareBalance.toString(),\n      bbondBalance: bbondBalance.toString(),\n      // bombPrice: bombPriceBN.toString(),\n      // bsharePrice: bsharePriceBN.toString(),\n      rateBSharePerBomb: rateBSharePerBombBN.toString()\n    };\n  }\n\n}","map":{"version":3,"sources":["/home/shashwat/Projects/Intern/src/bomb-finance/BombFinance.ts"],"names":["Fetcher","Route","Token","BigNumber","Contract","ethers","decimalToBalance","ERC20","getFullDisplayBalance","getDisplayBalance","getDefaultProvider","IUniswapV2PairABI","IBombBorrowableABI","config","bankDefinitions","moment","parseUnits","BNB_TICKER","SPOOKY_ROUTER_ADDR","BOMB_TICKER","bombMaxi","BombFinance","constructor","cfg","myAccount","provider","signer","contracts","externalTokens","boardroomVersionOfUser","BOMBBTCB_LP","BOMB","BUSD","BSHARE","BBOND","XBOMB","BNB","BTC","BOMB_BORROWABLE","BTCB_BORROWABLE","BBOMB_BOMB","BBOMB_BTCB","BBOMBBOMB","BBOMBBTCB","BUSMBUSD_LP","BUSM","BOMB_MAXI","BSHARE_MAXI","deployments","name","deployment","Object","entries","address","abi","symbol","decimal","Bomb","BShare","BBond","xBOMB","BombBorrowable","BtcbBorrowable","BombMaxiLPBShareRewardPool","BshareMaxiLPBShareRewardPool","unlockWallet","account","newProvider","providers","Web3Provider","chainId","getSigner","contract","connect","tokens","values","token","console","log","fetchBoardroomVersionOfUser","then","version","catch","err","error","stack","isUnlocked","getBombStat","BombRewardPool","BombGenesisRewardPool","supply","totalSupply","bombRewardPoolSupply","balanceOf","bombRewardPoolSupply2","bombCirculatingSupply","sub","priceInBTC","getTokenPriceFromPancakeswapBTC","priceOfOneBTC","getBTCBPriceFromPancakeswap","priceOfBombInDollars","Number","toFixed","tokenInFtm","toString","priceInDollars","circulatingSupply","getBTCPriceUSD","getLPStat","lpToken","lpTokenSupplyBN","lpTokenSupply","token0","startsWith","isBomb","tokenAmountBN","tokenAmount","ftmAmountBN","ftmAmount","tokenAmountInOneLP","ftmAmountInOneLP","lpTokenPrice","getLPTokenPrice","lpTokenPriceFixed","liquidity","priceOfOne","totalLiquidity","getLPStatBTC","btcAmountBN","btcAmount","getBondStat","Treasury","bombStat","bondBombRatioBN","getBondPremiumRate","modifier","bondPriceInBNB","priceOfBBondInDollars","displayedTotalSupply","getShareStat","BShareRewardPool","priceInBNB","getTokenPriceFromPancakeswap","tShareCirculatingSupply","priceOfOneBNB","getWBNBPriceFromPancakeswap","priceOfSharesInDollars","getBombStatInEstimatedTWAP","Oracle","expectedPrice","twap","utils","parseEther","getBombPriceInLastTWAP","getBombUpdatedPrice","getBondsPurchasable","getBurnableBombLeft","getBombMaxiStats","poolId","BombMaxi","totalShares","data","pool","getPoolAPRs","bank","undefined","depositToken","poolContract","depositTokenValue","depositTokenName","depositTokenPrice","getDepositTokenPriceInDollars","stakeInPool","TVL","stat","earnTokenName","tokenPerSecond","getTokenPerSecond","tokenPerHour","mul","totalRewardPricePerYear","totalRewardPricePerDay","totalStakingTokenInPool","dailyAPR","yearlyAPR","getXbombAPR","bombToken","xbombToken","xbombExchange","getXbombExchange","xbombPercent","xbombPercentTotal","startDate","Date","nowDate","now","difference","getTime","days","aprPerDay","contractName","endsWith","rewardPerSecond","tSharePerSecond","div","poolStartTime","startDateTime","toNumber","FOUR_DAYS","epochBombPerSecond","tokenName","tokenPrice","priceOfOneFtmInDollars","getBusdLPTokenPrice","getMaxiLPTokenPrice","getCurrentEpoch","epoch","getBondOraclePriceInLastTWAP","buyBonds","amount","treasuryBombPrice","getBombPrice","redeemBonds","priceForBomb","getTotalValueLocked","totalValue","bankInfo","tokenAmountInPool","value","poolValue","isNaN","BSHAREPrice","BOMBPrice","boardroomtShareBalanceOf","currentBoardroom","bombStakeBalanceOf","boardroomTVL","bombTVL","tokenSupply","priceOfToken","tokenInLP","priceToken","getTokenPriceFromPancakeswapBUSD","maxiPool","bombmaxi","earnedFromBank","poolName","pendingBOMB","pendingShare","from","stakedBalanceOnBank","userInfo","stake","deposit","unstake","withdraw","harvest","exit","Boardroom","isOldBoardroomMember","tokenContract","ready","WBNB","wftm","wftmToToken","fetchPairData","priceInBUSD","midPrice","btcb","priceForPeg","getTokenPriceFromPancakeswapBOMBUSD","FUSDT","fusdt_wftm_lp_pair","ftm_amount_BN","ftm_amount","fusdt_amount_BN","fusdt_amount","BTCB","btcPriceInBNB","wbnbPrice","btcprice","getBoardroomAPR","latestSnapshotIndex","lastHistory","boardroomHistory","lastRewardsReceived","epochRewardsPerShare","amountOfRewardsPerDay","realAPR","getBombStakeAPR","xBombBombBalanceOf","canUserClaimRewardFromBoardroom","canClaimReward","canUserUnstakeFromBoardroom","canWithdraw","stakedAmount","getStakedSharesOnBoardroom","notStaked","result","timeUntilClaimRewardFromBoardroom","getTotalStakedInBoardroom","stakeShareToBoardroom","Error","stakeToBomb","Xbomb","enter","redeemFromBomb","BombRouter","expiry","redeem","redeemFromBtcb","supplyToBtcb","mint","supplyToBomb","getShareOf","getStakedBomb","getTotalStakedBomb","bomb","getTotalSuppliedBomb","bbombBomb","totalBomb","totalBalance","getTotalSuppliedBtcb","totalBtcb","XbombExchange","getExchangeRate","xBombPerBomb","parseFloat","xBombRate","withdrawFromBomb","leave","getEarningsOnBoardroom","getCashEarningsOf","earned","withdrawShareFromBoardroom","harvestCashFromBoardroom","claimDividends","claimReward","exitFromBoardroom","getTreasuryNextAllocationTime","nextEpochTimestamp","nextEpochPoint","nextAllocation","prevAllocation","to","getUserClaimRewardTime","currentEpoch","mason","members","startTimeEpoch","epochTimerStart","period","PERIOD","periodInHours","rewardLockupEpochs","targetEpochForClaimUnlock","fromDate","toDate","delta","endDate","add","getUserUnstakeTime","PeriodInHours","withdrawLockupEpochs","watchAssetInMetamask","assetName","ethereum","window","networkVersion","asset","assetUrl","request","method","params","type","options","decimals","image","provideBombFtmLP","bombAmount","TaxOffice","overrides","addLiquidityETHTaxFree","quoteFromSpooky","SpookyRouter","_reserve0","_reserve1","getReserves","quote","listenForRegulationsEvents","treasuryDaoFundedFilter","filters","DaoFundFunded","treasuryDevFundedFilter","DevFundFunded","treasuryBoardroomFundedFilter","BoardroomFunded","boughtBondsFilter","BoughtBonds","redeemBondsFilter","RedeemedBonds","epochBlocksRanges","boardroomFundEvents","queryFilter","events","forEach","callback","index","push","boardroomFund","args","startBlock","blockNumber","boughBonds","redeemedBonds","endBlock","bondsBought","getBondsWithFilterForPeriod","bondsRedeemed","DEVFundEvents","devFund","DAOFundEvents","daoFund","filter","bondsAmount","length","estimateZapIn","lpName","zapper","estimate","estimateZapInToken","zapIn","zapInToken","swapBBondToBShare","bbondAmount","BShareSwapper","estimateAmountOfBShare","estimateBN","getBShareSwapperStat","bshareBalanceBN","getBShareBalance","bbondBalanceBN","getBBondBalance","rateBSharePerBombBN","getBShareAmountPerBomb","bshareBalance","bbondBalance","rateBSharePerBomb"],"mappings":"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","sourcesContent":["// import { Fetcher, Route, Token } from '@uniswap/sdk';\n//import { Fetcher as FetcherSpirit, Token as TokenSpirit } from '@spiritswap/sdk';\nimport { Fetcher, Route, Token } from '@pancakeswap/sdk';\nimport { Configuration } from './config';\nimport { MaxiInfo, ContractName, TokenStat, AllocationTime, LPStat, Bank, PoolStats, BShareSwapperStat } from './types';\nimport { BigNumber, Contract, ethers, EventFilter } from 'ethers';\nimport { decimalToBalance } from './ether-utils';\nimport { TransactionResponse } from '@ethersproject/providers';\nimport ERC20 from './ERC20';\nimport { getFullDisplayBalance, getDisplayBalance } from '../utils/formatBalance';\nimport { getDefaultProvider } from '../utils/provider';\nimport IUniswapV2PairABI from './IUniswapV2Pair.abi.json';\nimport IBombBorrowableABI from './IBombBorrowable.abi.json';\n\nimport config, { bankDefinitions } from '../config';\nimport moment from 'moment';\nimport { parseUnits } from 'ethers/lib/utils';\nimport { BNB_TICKER, SPOOKY_ROUTER_ADDR, BOMB_TICKER } from '../utils/constants';\nimport { bombMaxi } from '../services/graph';\n\n/**\n * An API module of Bomb Money contracts.\n * All contract-interacting domain logic should be defined in here.\n */\nexport class BombFinance {\n  myAccount: string;\n  provider: ethers.providers.Web3Provider;\n  signer?: ethers.Signer;\n  config: Configuration;\n  contracts: { [name: string]: Contract };\n  externalTokens: { [name: string]: ERC20 };\n  boardroomVersionOfUser?: string;\n\n  BOMBBTCB_LP: Contract;\n  BOMB: ERC20;\n  BUSD: ERC20;\n  BSHARE: ERC20;\n  BBOND: ERC20;\n  XBOMB: ERC20;\n  BNB: ERC20;\n  BTC: ERC20;\n  BOMB_BORROWABLE: Contract;\n  BTCB_BORROWABLE: Contract;\n  BBOMB_BOMB: ERC20;\n  BBOMB_BTCB: ERC20;\n  BBOMBBOMB: ERC20;\n  BBOMBBTCB: ERC20;\n  BUSMBUSD_LP: Contract;\n  BUSM: ERC20;\n  BOMB_MAXI: ERC20;\n  BSHARE_MAXI: ERC20;\n\n  constructor(cfg: Configuration) {\n    const { deployments, externalTokens } = cfg;\n    const provider = getDefaultProvider();\n\n    // loads contracts from deployments\n    this.contracts = {};\n    for (const [name, deployment] of Object.entries(deployments)) {\n      this.contracts[name] = new Contract(deployment.address, deployment.abi, provider);\n    }\n    this.externalTokens = {};\n    for (const [symbol, [address, decimal]] of Object.entries(externalTokens)) {\n      this.externalTokens[symbol] = new ERC20(address, provider, symbol, decimal);\n    }\n    this.BOMB = new ERC20(deployments.Bomb.address, provider, 'BOMB');\n    this.BSHARE = new ERC20(deployments.BShare.address, provider, 'BSHARE');\n    this.BBOND = new ERC20(deployments.BBond.address, provider, 'BBOND');\n    this.BNB = this.externalTokens['WBNB'];\n    this.BTC = this.externalTokens['BTCB'];\n    this.XBOMB = new ERC20(deployments.xBOMB.address, provider, 'XBOMB');\n    this.BUSM = this.externalTokens['BUSM'];\n    this.BUSD = this.externalTokens['BUSD'];\n\n    // this.BBOMB_BOMB = new ERC20(deployments.BombBorrowable.address, provider, 'bBOMB');\n    // this.BBOMB_BTCB = new ERC20(deployments.BtcbBorrowable.address, provider, 'bBOMB');\n\n    // this.BBOMB_BOMB = new Contract(externalTokens['BBOMB-BOMB'][0], IBombBorrowableABI, provider);\n    // this.BBOMB_BTCB = new Contract(externalTokens['BBOMB-BTCB'][0], IBombBorrowableABI, provider);\n    this.BBOMB_BOMB = new ERC20(deployments.BombBorrowable.address, provider, 'bBOMB');\n    this.BBOMBBOMB = this.externalTokens['BBOMB-BOMB'];\n    this.BBOMBBTCB = this.externalTokens['BBOMB-BTCB'];\n\n    this.BBOMB_BTCB = new ERC20(deployments.BtcbBorrowable.address, provider, 'bBOMB');\n    this.BOMB_BORROWABLE = new Contract(externalTokens['BBOMB-BOMB'][0], IBombBorrowableABI, provider);\n    this.BTCB_BORROWABLE = new Contract(externalTokens['BBOMB-BTCB'][0], IBombBorrowableABI, provider);\n\n    this.BOMB_MAXI = new ERC20(deployments.BombMaxiLPBShareRewardPool.address, provider, '80BOMB-20BTCB-LP');\n    this.BSHARE_MAXI = new ERC20(deployments.BshareMaxiLPBShareRewardPool.address, provider, '80BSHARE-20WBNB-LP');\n\n    // Uniswap V2 Pair\n\n    this.BOMBBTCB_LP = new Contract(externalTokens['BOMB-BTCB-LP'][0], IUniswapV2PairABI, provider);\n    this.BUSMBUSD_LP = new Contract(externalTokens['BUSM-BUSD-LP'][0], IUniswapV2PairABI, provider);\n\n    this.config = cfg;\n    this.provider = provider;\n  }\n\n  /**\n   * @param provider From an unlocked wallet. (e.g. Metamask)\n   * @param account An address of unlocked wallet account.\n   */\n  unlockWallet(provider: any, account: string) {\n    const newProvider = new ethers.providers.Web3Provider(provider, this.config.chainId);\n    this.signer = newProvider.getSigner(0);\n    this.myAccount = account;\n    for (const [name, contract] of Object.entries(this.contracts)) {\n      this.contracts[name] = contract.connect(this.signer);\n    }\n    const tokens = [this.BOMB, this.BSHARE, this.BBOND, ...Object.values(this.externalTokens)];\n    for (const token of tokens) {\n      token.connect(this.signer);\n    }\n    this.BOMBBTCB_LP = this.BOMBBTCB_LP.connect(this.signer);\n    console.log(`ðŸ”“ Wallet is unlocked. Welcome, ${account}!`);\n    this.fetchBoardroomVersionOfUser()\n      .then((version) => (this.boardroomVersionOfUser = version))\n      .catch((err) => {\n        console.error(`Failed to fetch boardroom version: ${err.stack}`);\n        this.boardroomVersionOfUser = 'latest';\n      });\n  }\n\n  get isUnlocked(): boolean {\n    return !!this.myAccount;\n  }\n\n  //===================================================================\n  //===================== GET ASSET STATS =============================\n  //===================FROM APE TO DISPLAY =========================\n  //=========================IN HOME PAGE==============================\n  //===================================================================\n\n  async getBombStat(): Promise<TokenStat> {\n    const { BombRewardPool, BombGenesisRewardPool } = this.contracts;\n    const supply = await this.BOMB.totalSupply();\n    const bombRewardPoolSupply = await this.BOMB.balanceOf(BombGenesisRewardPool.address);\n    const bombRewardPoolSupply2 = await this.BOMB.balanceOf(BombRewardPool.address);\n    const bombCirculatingSupply = supply.sub(bombRewardPoolSupply).sub(bombRewardPoolSupply2);\n    //  const priceInBNB = await this.getTokenPriceFromPancakeswap(this.BOMB);\n    //const priceInBNBstring = priceInBNB.toString();\n    const priceInBTC = await this.getTokenPriceFromPancakeswapBTC(this.BOMB);\n    // const priceOfOneBNB = await this.getWBNBPriceFromPancakeswap();\n    const priceOfOneBTC = await this.getBTCBPriceFromPancakeswap();\n    //const priceInDollars = await this.getTokenPriceFromPancakeswapBOMBUSD();\n    const priceOfBombInDollars = ((Number(priceInBTC) * Number(priceOfOneBTC)) / 10000).toFixed(2);\n    //console.log('priceOfBombInDollars', priceOfBombInDollars);\n\n    return {\n      //  tokenInFtm: (Number(priceInBNB) * 100).toString(),\n      tokenInFtm: priceInBTC.toString(),\n      priceInDollars: priceOfBombInDollars,\n      totalSupply: getDisplayBalance(supply, this.BOMB.decimal, 0),\n      circulatingSupply: getDisplayBalance(bombCirculatingSupply, this.BOMB.decimal, 0),\n    };\n  }\n\n  async getBTCPriceUSD(): Promise<Number> {\n    const priceOfOneBTC = await this.getBTCBPriceFromPancakeswap();\n    return Number(priceOfOneBTC);\n  }\n\n  /**\n   * Calculates various stats for the requested LP\n   * @param name of the LP token to load stats for\n   * @returns\n   */\n  async getLPStat(name: string): Promise<LPStat> {\n    // console.log('NAME', name);\n\n    const lpToken = this.externalTokens[name];\n    const lpTokenSupplyBN = await lpToken.totalSupply();\n    const lpTokenSupply = getDisplayBalance(lpTokenSupplyBN, 18);\n    const token0 = name.startsWith('BOMB') ? this.BOMB : this.BSHARE;\n    // console.log('NAME', name);\n\n    const isBomb = name.startsWith('BOMB');\n    const tokenAmountBN = await token0.balanceOf(lpToken.address);\n    const tokenAmount = getDisplayBalance(tokenAmountBN, 18);\n\n    const ftmAmountBN = await this.BNB.balanceOf(lpToken.address);\n    const ftmAmount = getDisplayBalance(ftmAmountBN, 18);\n    const tokenAmountInOneLP = Number(tokenAmount) / Number(lpTokenSupply);\n    const ftmAmountInOneLP = Number(ftmAmount) / Number(lpTokenSupply);\n    const lpTokenPrice = await this.getLPTokenPrice(lpToken, token0, isBomb);\n    const lpTokenPriceFixed = Number(lpTokenPrice).toFixed(2).toString();\n    const liquidity = (Number(lpTokenSupply) * Number(lpTokenPrice)).toFixed(2).toString();\n    return {\n      tokenAmount: tokenAmountInOneLP.toFixed(2).toString(),\n      ftmAmount: ftmAmountInOneLP.toFixed(2).toString(),\n      priceOfOne: lpTokenPriceFixed,\n      totalLiquidity: liquidity,\n      totalSupply: Number(lpTokenSupply).toFixed(2).toString(),\n    };\n  }\n\n  async getLPStatBTC(name: string): Promise<LPStat> {\n    const lpToken = this.externalTokens[name];\n    const lpTokenSupplyBN = await lpToken.totalSupply();\n    const lpTokenSupply = getDisplayBalance(lpTokenSupplyBN, 18);\n    const token0 = name.startsWith('BOMB') ? this.BOMB : this.BSHARE;\n    const isBomb = name.startsWith('BOMB');\n    const tokenAmountBN = await token0.balanceOf(lpToken.address);\n    const tokenAmount = getDisplayBalance(tokenAmountBN, 18);\n\n    const btcAmountBN = await this.BTC.balanceOf(lpToken.address);\n    const btcAmount = getDisplayBalance(btcAmountBN, 18);\n    const tokenAmountInOneLP = Number(tokenAmount) / Number(lpTokenSupply);\n    const ftmAmountInOneLP = Number(btcAmount) / Number(lpTokenSupply);\n    const lpTokenPrice = await this.getLPTokenPrice(lpToken, token0, isBomb);\n\n    const lpTokenPriceFixed = Number(lpTokenPrice).toFixed(2).toString();\n\n    const liquidity = (Number(lpTokenSupply) * Number(lpTokenPrice)).toFixed(2).toString();\n\n    return {\n      tokenAmount: tokenAmountInOneLP.toFixed(2).toString(),\n      ftmAmount: ftmAmountInOneLP.toFixed(5).toString(),\n      priceOfOne: lpTokenPriceFixed,\n      totalLiquidity: liquidity,\n      totalSupply: Number(lpTokenSupply).toFixed(2).toString(),\n    };\n  }\n  /**\n   * Use this method to get price for Bomb\n   * @returns TokenStat for BBOND\n   * priceInBNB\n   * priceInDollars\n   * TotalSupply\n   * CirculatingSupply (always equal to total supply for bonds)\n   */\n  async getBondStat(): Promise<TokenStat> {\n    const { Treasury } = this.contracts;\n    const bombStat = await this.getBombStat();\n    const bondBombRatioBN = await Treasury.getBondPremiumRate();\n    const modifier = bondBombRatioBN / 1e14 > 1 ? bondBombRatioBN / 1e14 : 1;\n    const bondPriceInBNB = (Number(bombStat.tokenInFtm) * modifier).toFixed(4);\n    const priceOfBBondInDollars = (Number(bombStat.priceInDollars) * modifier).toFixed(4);\n    const supply = await this.BBOND.displayedTotalSupply();\n    return {\n      tokenInFtm: bondPriceInBNB,\n      priceInDollars: priceOfBBondInDollars,\n      totalSupply: supply,\n      circulatingSupply: supply,\n    };\n  }\n\n  /**\n   * @returns TokenStat for BSHARE\n   * priceInBNB\n   * priceInDollars\n   * TotalSupply\n   * CirculatingSupply (always equal to total supply for bonds)\n   */\n  async getShareStat(): Promise<TokenStat> {\n    const { BShareRewardPool } = this.contracts;\n\n    const supply = await this.BSHARE.totalSupply();\n\n    const priceInBNB = await this.getTokenPriceFromPancakeswap(this.BSHARE);\n    const bombRewardPoolSupply = await this.BSHARE.balanceOf(BShareRewardPool.address);\n    const tShareCirculatingSupply = supply.sub(bombRewardPoolSupply);\n    const priceOfOneBNB = await this.getWBNBPriceFromPancakeswap();\n    const priceOfSharesInDollars = (Number(priceInBNB) * Number(priceOfOneBNB)).toFixed(2);\n\n    return {\n      tokenInFtm: priceInBNB,\n      priceInDollars: priceOfSharesInDollars,\n      totalSupply: getDisplayBalance(supply, this.BSHARE.decimal, 0),\n      circulatingSupply: getDisplayBalance(tShareCirculatingSupply, this.BSHARE.decimal, 0),\n    };\n  }\n\n  async getBombStatInEstimatedTWAP(): Promise<TokenStat> {\n    const { Oracle, BombRewardPool } = this.contracts;\n    const expectedPrice = await Oracle.twap(this.BOMB.address, ethers.utils.parseEther('10000'));\n\n    const supply = await this.BOMB.totalSupply();\n    const bombRewardPoolSupply = await this.BOMB.balanceOf(BombRewardPool.address);\n    const bombCirculatingSupply = supply.sub(bombRewardPoolSupply);\n    return {\n      tokenInFtm: getDisplayBalance(expectedPrice),\n      priceInDollars: getDisplayBalance(expectedPrice),\n      totalSupply: getDisplayBalance(supply, this.BOMB.decimal, 0),\n      circulatingSupply: getDisplayBalance(bombCirculatingSupply, this.BOMB.decimal, 0),\n    };\n  }\n\n  async getBombPriceInLastTWAP(): Promise<BigNumber> {\n    const { Treasury } = this.contracts;\n    return Treasury.getBombUpdatedPrice();\n  }\n\n  // async getBombPegTWAP(): Promise<any> {\n  //   const { Treasury } = this.contracts;\n  //   const updatedPrice = Treasury.getBombUpdatedPrice();\n  //   const updatedPrice2 = updatedPrice * 10000;\n  //   return updatedPrice2;\n  // }\n\n  async getBondsPurchasable(): Promise<BigNumber> {\n    const { Treasury } = this.contracts;\n    // const burnableBomb = (Number(Treasury.getBurnableBombLeft()) * 1000).toFixed(2).toString();\n    return Treasury.getBurnableBombLeft();\n  }\n\n  async getBombMaxiStats(poolId: string): Promise<MaxiInfo> {\n    const BombMaxi = await bombMaxi(poolId);\n    return {\n      totalShares: BombMaxi.data.pool.totalShares.toString(),\n      totalLiquidity: BombMaxi.data.pool.totalLiquidity.toString(),\n\n      // tokenAmount: tokenAmountInOneLP.toFixed(2).toString(),\n      // ftmAmount: ftmAmountInOneLP.toFixed(2).toString(),\n      // priceOfOne: lpTokenPriceFixed,\n      // totalLiquidity: liquidity,\n      // totalSupply: Number(lpTokenSupply).toFixed(2).toString(),\n    };\n  }\n\n  /**\n   * Calculates the TVL, APR and daily APR of a provided pool/bank\n   * @param bank\n   * @returns\n   */\n  async getPoolAPRs(bank: Bank): Promise<PoolStats> {\n    if (this.myAccount === undefined) return;\n    let depositToken = bank.depositToken;\n    // if (depositToken.symbol === '80BOMB-20BTCB-LP' || depositToken.symbol === '80BSHARE-20WBNB-LP') {\n    //   const temp = 'TBD';\n    //   return {\n    //     dailyAPR: temp,\n    //     yearlyAPR: temp,\n    //     TVL: temp,\n    //   };\n    // }\n    const poolContract = this.contracts[bank.contract];\n    let depositTokenValue: ERC20\n    if (bank.depositTokenName === \"BBOND\") {\n      depositTokenValue = this.BOMB\n    } else {\n      depositTokenValue = depositToken\n    }\n    const depositTokenPrice = await this.getDepositTokenPriceInDollars(bank.depositTokenName, depositTokenValue);\n    const stakeInPool = await depositToken.balanceOf(bank.address);\n    const TVL = Number(depositTokenPrice) * Number(getDisplayBalance(stakeInPool, depositToken.decimal));\n    const stat = bank.earnTokenName === 'BOMB' ? await this.getBombStat() : await this.getShareStat();\n    const tokenPerSecond = await this.getTokenPerSecond(\n      bank.earnTokenName,\n      bank.contract,\n      poolContract,\n      bank.depositTokenName,\n    );\n\n    const tokenPerHour = tokenPerSecond.mul(60).mul(60);\n    const totalRewardPricePerYear =\n      Number(stat.priceInDollars) * Number(getDisplayBalance(tokenPerHour.mul(24).mul(365)));\n    const totalRewardPricePerDay = Number(stat.priceInDollars) * Number(getDisplayBalance(tokenPerHour.mul(24)));\n    const totalStakingTokenInPool =\n      Number(depositTokenPrice) * Number(getDisplayBalance(stakeInPool, depositToken.decimal));\n    const dailyAPR = (totalRewardPricePerDay / totalStakingTokenInPool) * 100;\n    const yearlyAPR = (totalRewardPricePerYear / totalStakingTokenInPool) * 100;\n    return {\n      dailyAPR: dailyAPR.toFixed(2).toString(),\n      yearlyAPR: yearlyAPR.toFixed(2).toString(),\n      TVL: TVL.toFixed(2).toString(),\n    };\n  }\n\n  async getXbombAPR(): Promise<PoolStats> {\n    if (this.myAccount === undefined) return;\n    const bombToken = this.BOMB;\n    const xbombToken = this.XBOMB;\n\n    const xbombExchange = await this.getXbombExchange();\n    const xbombPercent = await xbombExchange;\n    const xbombPercentTotal = (Number(xbombPercent) / 1000000000000000000) * 100 - 100;\n\n    const depositTokenPrice = await this.getDepositTokenPriceInDollars(bombToken.symbol, bombToken);\n\n    const stakeInPool = await bombToken.balanceOf(xbombToken.address);\n\n    const TVL = Number(depositTokenPrice) * Number(getDisplayBalance(stakeInPool, bombToken.decimal));\n\n    const startDate = new Date('January 24, 2022');\n    const nowDate = new Date(Date.now());\n    const difference = nowDate.getTime() - startDate.getTime();\n    const days = difference / 60 / 60 / 24 / 1000;\n    const aprPerDay = xbombPercentTotal / days;\n\n    // Determine days between now and a date\n\n    // const tokenPerHour = tokenPerSecond.mul(60).mul(60);\n    // const totalRewardPricePerYear =\n    //   Number(stat.priceInDollars) * Number(getDisplayBalance(tokenPerHour.mul(24).mul(365)));\n    // const totalRewardPricePerDay = Number(stat.priceInDollars) * Number(getDisplayBalance(tokenPerHour.mul(24)));\n    // const totalStakingTokenInPool =\n    //   Number(depositTokenPrice) * Number(getDisplayBalance(stakeInPool, depositToken.decimal));\n    // const dailyAPR = (totalRewardPricePerDay / totalStakingTokenInPool) * 100;\n    // const yearlyAPR = (totalRewardPricePerYear / totalStakingTokenInPool) * 100;\n\n    const dailyAPR = aprPerDay;\n    const yearlyAPR = aprPerDay * 365;\n    return {\n      dailyAPR: dailyAPR.toFixed(2).toString(),\n      yearlyAPR: yearlyAPR.toFixed(2).toString(),\n      TVL: TVL.toFixed(2).toString(),\n    };\n  }\n\n  /**\n   * Method to return the amount of tokens the pool yields per second\n   * @param earnTokenName the name of the token that the pool is earning\n   * @param contractName the contract of the pool/bank\n   * @param poolContract the actual contract of the pool\n   * @returns\n   */\n  async getTokenPerSecond(\n    earnTokenName: string,\n    contractName: string,\n    poolContract: Contract,\n    depositTokenName: string,\n  ) {\n    if (earnTokenName === 'BOMB') {\n      if (!contractName.endsWith('BombRewardPool')) {\n        const rewardPerSecond = await poolContract.tSharePerSecond();\n        if (depositTokenName === 'WBNB') {\n          return rewardPerSecond.mul(6000).div(11000).div(24);\n        } else if (depositTokenName === 'CAKE') {\n          return rewardPerSecond.mul(2500).div(11000).div(24);\n        } else if (depositTokenName === 'SUSD') {\n          return rewardPerSecond.mul(1000).div(11000).div(24);\n        } else if (depositTokenName === 'SVL') {\n          return rewardPerSecond.mul(1500).div(11000).div(24);\n        }\n        return rewardPerSecond.div(24);\n      }\n      const poolStartTime = await poolContract.poolStartTime();\n      const startDateTime = new Date(poolStartTime.toNumber() * 1000);\n      const FOUR_DAYS = 4 * 24 * 60 * 60 * 1000;\n      if (Date.now() - startDateTime.getTime() > FOUR_DAYS) {\n        return await poolContract.epochBombPerSecond(1);\n      }\n      return await poolContract.epochBombPerSecond(0);\n    }\n    const rewardPerSecond = await poolContract.tSharePerSecond();\n    if (depositTokenName.startsWith('BOMB-BTCB')) {\n      return rewardPerSecond.mul(400).div(1000);\n    } else if (depositTokenName.startsWith('BOMB-BSHARE')) {\n      return rewardPerSecond.mul(0).div(1000);\n    } else if (depositTokenName.startsWith('BOMB')) {\n      return rewardPerSecond.mul(0).div(1000);\n    } else if (depositTokenName.startsWith('BBOND')) {\n      return rewardPerSecond.mul(150).div(1000);\n    } else if (depositTokenName.startsWith('BUSM-BUSD')) {\n      return rewardPerSecond.mul(50).div(1000);\n    } else if (depositTokenName.startsWith('80BOMB')) {\n      return rewardPerSecond.mul(200).div(1000);\n    } else if (depositTokenName.startsWith('80BSHARE')) {\n      return rewardPerSecond.mul(50).div(1000);\n    } else {\n      return rewardPerSecond.mul(150).div(1000);\n    }\n    // if (depositTokenName.startsWith('BOMB-BTCB')) {\n    //   return rewardPerSecond.mul(41650).div(10000);\n    // } else if (depositTokenName.startsWith('BOMB-BSHARE')) {\n    //   return rewardPerSecond.mul(0).div(119000);\n    // } else if (depositTokenName.startsWith('BOMB')) {\n    //   return rewardPerSecond.mul(59500).div(10000);\n    // } else {\n    //   return rewardPerSecond.mul(17850).div(10000);\n    // }\n  }\n\n  /**\n   * Method to calculate the tokenPrice of the deposited asset in a pool/bank\n   * If the deposited token is an LP it will find the price of its pieces\n   * @param tokenName\n   * @param pool\n   * @param token\n   * @returns\n   */\n  async getDepositTokenPriceInDollars(tokenName: string, token: ERC20) {\n    let tokenPrice;\n    const priceOfOneFtmInDollars = await this.getWBNBPriceFromPancakeswap();\n    if (tokenName === 'WBNB') {\n      tokenPrice = priceOfOneFtmInDollars;\n    } else {\n      if (tokenName === 'BOMB-BTCB-LP') {\n        tokenPrice = await this.getLPTokenPrice(token, this.BOMB, true);\n      } else if (tokenName === 'BSHARE-BNB-LP') {\n        tokenPrice = await this.getLPTokenPrice(token, this.BSHARE, false);\n      } else if (tokenName === 'BOMB-BSHARE-LP') {\n        tokenPrice = await this.getLPTokenPrice(token, this.BOMB, true);\n        // } else if (tokenName === 'BSHARE-BNB-APELP') {\n        //   tokenPrice = await this.getLPTokenPrice(token, this.BSHARE, false);\n      } else if (tokenName === 'BUSM-BUSD-LP') {\n        tokenPrice = await this.getBusdLPTokenPrice(token, this.BUSM, true);\n      } else if (tokenName === '80BOMB-20BTCB-LP') {\n        tokenPrice = await this.getMaxiLPTokenPrice(\n          '0xd6f52e8ab206e59a1e13b3d6c5b7f31e90ef46ef000200000000000000000028',\n        );\n      } else if (tokenName === '80BSHARE-20WBNB-LP') {\n        tokenPrice = await this.getMaxiLPTokenPrice(\n          '0x2c374ed1575e5c2c02c569f627299e902a1972cb000200000000000000000027',\n        );\n      }\n      else if (tokenName === 'BBOND') {\n        tokenPrice = await this.getTokenPriceFromPancakeswap(this.BOMB);\n        tokenPrice = (Number(tokenPrice) * Number(priceOfOneFtmInDollars)).toString();\n\n\n      } else {\n        tokenPrice = await this.getTokenPriceFromPancakeswap(token);\n        tokenPrice = (Number(tokenPrice) * Number(priceOfOneFtmInDollars)).toString();\n      }\n    }\n    //console.log({ tokenPrice });\n    return tokenPrice;\n  }\n\n  //===================================================================\n  //===================== GET ASSET STATS =============================\n  //=========================== END ===================================\n  //===================================================================\n\n  async getCurrentEpoch(): Promise<BigNumber> {\n    const { Treasury } = this.contracts;\n    return Treasury.epoch();\n  }\n\n  async getBondOraclePriceInLastTWAP(): Promise<BigNumber> {\n    const { Treasury } = this.contracts;\n    return Treasury.getBondPremiumRate();\n  }\n\n  /**\n   * Buy bonds with cash.\n   * @param amount amount of cash to purchase bonds with.\n   */\n  async buyBonds(amount: string | number): Promise<TransactionResponse> {\n    const { Treasury } = this.contracts;\n    const treasuryBombPrice = await Treasury.getBombPrice();\n    return await Treasury.buyBonds(decimalToBalance(amount), treasuryBombPrice);\n  }\n\n  /**\n   * Redeem bonds for cash.\n   * @param amount amount of bonds to redeem.\n   */\n  async redeemBonds(amount: string | number): Promise<TransactionResponse> {\n    const { Treasury } = this.contracts;\n    const priceForBomb = await Treasury.getBombPrice();\n\n    return await Treasury.redeemBonds(decimalToBalance(amount), priceForBomb);\n  }\n\n  async getTotalValueLocked(): Promise<Number> {\n    let totalValue = 0;\n    for (const bankInfo of Object.values(bankDefinitions)) {\n      const pool = this.contracts[bankInfo.contract];\n      const token = this.externalTokens[bankInfo.depositTokenName];\n      const tokenPrice = await this.getDepositTokenPriceInDollars(bankInfo.depositTokenName, token);\n      const tokenAmountInPool = await token.balanceOf(pool.address);\n      const value = Number(getDisplayBalance(tokenAmountInPool, token.decimal)) * Number(tokenPrice);\n      const poolValue = Number.isNaN(value) ? 0 : value;\n      totalValue += poolValue;\n    }\n\n    const BSHAREPrice = (await this.getShareStat()).priceInDollars;\n    const BOMBPrice = (await this.getBombStat()).priceInDollars;\n\n    const boardroomtShareBalanceOf = await this.BSHARE.balanceOf(this.currentBoardroom().address);\n    const bombStakeBalanceOf = await this.BOMB.balanceOf(this.XBOMB.address);\n\n    const boardroomTVL = Number(getDisplayBalance(boardroomtShareBalanceOf, this.BSHARE.decimal)) * Number(BSHAREPrice);\n    const bombTVL = Number(getDisplayBalance(bombStakeBalanceOf, this.BOMB.decimal)) * Number(BOMBPrice);\n\n    return totalValue + boardroomTVL + bombTVL;\n  }\n\n  /**\n   * Calculates the price of an LP token\n   * Reference https://github.com/DefiDebauchery/discordpricebot/blob/4da3cdb57016df108ad2d0bb0c91cd8dd5f9d834/pricebot/pricebot.py#L150\n   * @param lpToken the token under calculation\n   * @param token the token pair used as reference (the other one would be BNB in most cases)\n   * @param isBomb sanity check for usage of bomb token or tShare\n   * @returns price of the LP token\n   */\n  async getLPTokenPrice(lpToken: ERC20, token: ERC20, isBomb: boolean): Promise<string> {\n    const totalSupply = getFullDisplayBalance(await lpToken.totalSupply(), lpToken.decimal);\n    //Get amount of tokenA\n    const tokenSupply = getFullDisplayBalance(await token.balanceOf(lpToken.address), token.decimal);\n    const stat = isBomb === true ? await this.getBombStat() : await this.getShareStat();\n    const priceOfToken = stat.priceInDollars;\n    const tokenInLP = Number(tokenSupply) / Number(totalSupply);\n    const tokenPrice = (Number(priceOfToken) * tokenInLP * 2) //We multiply by 2 since half the price of the lp token is the price of each piece of the pair. So twice gives the total\n      .toString();\n    return tokenPrice;\n  }\n\n  /**\n   * Calculates the price of an LP token\n   * Reference https://github.com/DefiDebauchery/discordpricebot/blob/4da3cdb57016df108ad2d0bb0c91cd8dd5f9d834/pricebot/pricebot.py#L150\n   * @param lpToken the token under calculation\n   * @param token the token pair used as reference (the other one would be BNB in most cases)\n   * @param isBomb sanity check for usage of bomb token or tShare\n   * @returns price of the LP token\n   */\n  async getBusdLPTokenPrice(lpToken: ERC20, token: ERC20, isBomb: boolean): Promise<string> {\n    const totalSupply = getFullDisplayBalance(await lpToken.totalSupply(), lpToken.decimal);\n    //Get amount of tokenA\n    const tokenSupply = getFullDisplayBalance(await token.balanceOf(lpToken.address), token.decimal);\n    // const stat = isBomb === true ? await this.getBombStat() : await this.getShareStat();\n    const priceToken = await this.getTokenPriceFromPancakeswapBUSD(this.BUSM);\n    const priceOfToken = Number(priceToken);\n    const tokenInLP = Number(tokenSupply) / Number(totalSupply);\n    const tokenPrice = (Number(priceOfToken) * tokenInLP * 2) //We multiply by 2 since half the price of the lp token is the price of each piece of the pair. So twice gives the total\n      .toString();\n    return tokenPrice;\n  }\n\n  async getMaxiLPTokenPrice(maxiPool: string): Promise<string> {\n    const bombmaxi = await this.getBombMaxiStats(maxiPool);\n    const totalShares = await bombmaxi.totalShares;\n    //Get amount of tokenA\n    const totalLiquidity = await bombmaxi.totalLiquidity;\n    // const stat = isBomb === true ? await this.getBombStat() : await this.getShareStat();\n\n    const tokenInLP = Number(totalLiquidity) / Number(totalShares);\n    const tokenPrice = tokenInLP //We multiply by 2 since half the price of the lp token is the price of each piece of the pair. So twice gives the total\n      .toString();\n    return tokenPrice;\n  }\n\n  async earnedFromBank(\n    poolName: ContractName,\n    earnTokenName: String,\n    poolId: Number,\n    account = this.myAccount,\n  ): Promise<BigNumber> {\n    const pool = this.contracts[poolName];\n    try {\n      if (earnTokenName === 'BOMB') {\n        return await pool.pendingBOMB(poolId, account);\n      } else {\n        return await pool.pendingShare(poolId, account);\n      }\n    } catch (err) {\n      console.error(`Failed to call pendingShare() on pool ${pool.address}: ${err.stack}`);\n      return BigNumber.from(0);\n    }\n  }\n\n  async stakedBalanceOnBank(poolName: ContractName, poolId: Number, account = this.myAccount): Promise<BigNumber> {\n    const pool = this.contracts[poolName];\n    try {\n      let userInfo = await pool.userInfo(poolId, account);\n      return await userInfo.amount;\n    } catch (err) {\n      console.error(`Failed to call userInfo() on pool ${pool.address}: ${err.stack}`);\n      return BigNumber.from(0);\n    }\n  }\n\n  /**\n   * Deposits token to given pool.\n   * @param poolName A name of pool contract.\n   * @param amount Number of tokens with decimals applied. (e.g. 1.45 DAI * 10^18)\n   * @returns {string} Transaction hash\n   */\n  async stake(poolName: ContractName, poolId: Number, amount: BigNumber): Promise<TransactionResponse> {\n    const pool = this.contracts[poolName];\n    return await pool.deposit(poolId, amount);\n  }\n\n  /**\n   * Withdraws token from given pool.\n   * @param poolName A name of pool contract.\n   * @param amount Number of tokens with decimals applied. (e.g. 1.45 DAI * 10^18)\n   * @returns {string} Transaction hash\n   */\n  async unstake(poolName: ContractName, poolId: Number, amount: BigNumber): Promise<TransactionResponse> {\n    const pool = this.contracts[poolName];\n    return await pool.withdraw(poolId, amount);\n  }\n\n  /**\n   * Transfers earned token reward from given pool to my account.\n   */\n  async harvest(poolName: ContractName, poolId: Number): Promise<TransactionResponse> {\n    const pool = this.contracts[poolName];\n    //By passing 0 as the amount, we are asking the contract to only redeem the reward and not the currently staked token\n    return await pool.withdraw(poolId, 0);\n  }\n\n  /**\n   * Harvests and withdraws deposited tokens from the pool.\n   */\n  async exit(poolName: ContractName, poolId: Number, account = this.myAccount): Promise<TransactionResponse> {\n    const pool = this.contracts[poolName];\n    let userInfo = await pool.userInfo(poolId, account);\n    return await pool.withdraw(poolId, userInfo.amount);\n  }\n\n  async fetchBoardroomVersionOfUser(): Promise<string> {\n    return 'latest';\n  }\n\n  currentBoardroom(): Contract {\n    if (!this.boardroomVersionOfUser) {\n      //throw new Error('you must unlock the wallet to continue.');\n    }\n    return this.contracts.Boardroom;\n  }\n\n  isOldBoardroomMember(): boolean {\n    return this.boardroomVersionOfUser !== 'latest';\n  }\n\n  async getTokenPriceFromPancakeswap(tokenContract: ERC20): Promise<string> {\n    const ready = await this.provider.ready;\n    if (!ready) return;\n    //const { chainId } = this.config;\n    const { WBNB } = this.config.externalTokens;\n\n    const wftm = new Token(56, WBNB[0], WBNB[1], 'WBNB');\n    const token = new Token(56, tokenContract.address, tokenContract.decimal, tokenContract.symbol);\n    try {\n      const wftmToToken = await Fetcher.fetchPairData(wftm, token, this.provider);\n      const priceInBUSD = new Route([wftmToToken], token);\n      return priceInBUSD.midPrice.toFixed(4);\n    } catch (err) {\n      console.error(`Failed to fetch token price of ${tokenContract.symbol}: ${err}`);\n    }\n  }\n\n  async getTokenPriceFromPancakeswapBUSD(tokenContract: ERC20): Promise<string> {\n    const ready = await this.provider.ready;\n    if (!ready) return;\n    //const { chainId } = this.config;\n    const { BUSD } = this.config.externalTokens;\n\n    const wftm = new Token(56, BUSD[0], BUSD[1], 'BUSD');\n    const token = new Token(56, tokenContract.address, tokenContract.decimal, tokenContract.symbol);\n    try {\n      const wftmToToken = await Fetcher.fetchPairData(wftm, token, this.provider);\n      const priceInBUSD = new Route([wftmToToken], token);\n      return priceInBUSD.midPrice.toFixed(4);\n    } catch (err) {\n      console.error(`Failed to fetch token price of ${tokenContract.symbol}: ${err}`);\n    }\n  }\n\n  async getTokenPriceFromPancakeswapBTC(tokenContract: ERC20): Promise<string> {\n    const ready = await this.provider.ready;\n    if (!ready) return;\n    //const { chainId } = this.config;\n    // const {WBNB} = this.config.externalTokens;\n\n    // const wbnb = new Token(56, WBNB[0], WBNB[1]);\n    const btcb = new Token(56, this.BTC.address, this.BTC.decimal, 'BTCB', 'BTCB');\n    const token = new Token(56, tokenContract.address, tokenContract.decimal, tokenContract.symbol);\n    try {\n      const wftmToToken = await Fetcher.fetchPairData(btcb, token, this.provider);\n      const priceInBUSD = new Route([wftmToToken], token);\n      //   console.log('priceInBUSDBTC', priceInBUSD.midPrice.toFixed(12));\n\n      const priceForPeg = Number(priceInBUSD.midPrice.toFixed(12)) * 10000;\n      return priceForPeg.toFixed(4);\n    } catch (err) {\n      console.error(`Failed to fetch token price of ${tokenContract.symbol}: ${err}`);\n    }\n  }\n\n  async getTokenPriceFromPancakeswapBOMBUSD(): Promise<string> {\n    const ready = await this.provider.ready;\n    if (!ready) return;\n    //const { chainId } = this.config;\n    //const {WBNB} = this.config.externalTokens;\n\n    //  const wbnb = new Token(56, WBNB[0], WBNB[1]);\n    const btcb = new Token(56, this.BTC.address, this.BTC.decimal, 'BTCB', 'BTCB');\n    const token = new Token(56, this.BOMB.address, this.BOMB.decimal, this.BOMB.symbol);\n    try {\n      const wftmToToken = await Fetcher.fetchPairData(btcb, token, this.provider);\n      const priceInBUSD = new Route([wftmToToken], token);\n      // console.log('test', priceInBUSD.midPrice.toFixed(12));\n\n      const priceForPeg = Number(priceInBUSD.midPrice.toFixed(12)) * 10000;\n      return priceForPeg.toFixed(4);\n    } catch (err) {\n      console.error(`Failed to fetch token price of ${this.BOMB.symbol}: ${err}`);\n    }\n  }\n\n  // async getTokenPriceFromSpiritswap(tokenContract: ERC20): Promise<string> {\n  //   const ready = await this.provider.ready;\n  //   if (!ready) return;\n  //   const { chainId } = this.config;\n\n  //   const { WBNB } = this.externalTokens;\n\n  //   const wftm = new TokenSpirit(chainId, WBNB.address, WBNB.decimal);\n  //   const token = new TokenSpirit(chainId, tokenContract.address, tokenContract.decimal, tokenContract.symbol);\n  //   try {\n  //     const wftmToToken = await FetcherSpirit.fetchPairData(wftm, token, this.provider);\n  //     const liquidityToken = wftmToToken.liquidityToken;\n  //     let ftmBalanceInLP = await WBNB.balanceOf(liquidityToken.address);\n  //     let ftmAmount = Number(getFullDisplayBalance(ftmBalanceInLP, WBNB.decimal));\n  //     let shibaBalanceInLP = await tokenContract.balanceOf(liquidityToken.address);\n  //     let shibaAmount = Number(getFullDisplayBalance(shibaBalanceInLP, tokenContract.decimal));\n  //     const priceOfOneFtmInDollars = await this.getWBNBPriceFromPancakeswap();\n  //     let priceOfShiba = (ftmAmount / shibaAmount) * Number(priceOfOneFtmInDollars);\n  //     return priceOfShiba.toString();\n  //   } catch (err) {\n  //     console.error(`Failed to fetch token price of ${tokenContract.symbol}: ${err}`);\n  //   }\n  // }\n\n  async getWBNBPriceFromPancakeswap(): Promise<string> {\n    const ready = await this.provider.ready;\n    if (!ready) return;\n    const { WBNB, FUSDT } = this.externalTokens;\n    try {\n      const fusdt_wftm_lp_pair = this.externalTokens['USDT-BNB-LP'];\n      let ftm_amount_BN = await WBNB.balanceOf(fusdt_wftm_lp_pair.address);\n      let ftm_amount = Number(getFullDisplayBalance(ftm_amount_BN, WBNB.decimal));\n      let fusdt_amount_BN = await FUSDT.balanceOf(fusdt_wftm_lp_pair.address);\n      let fusdt_amount = Number(getFullDisplayBalance(fusdt_amount_BN, FUSDT.decimal));\n      return (fusdt_amount / ftm_amount).toString();\n    } catch (err) {\n      console.error(`Failed to fetch token price of WBNB: ${err}`);\n    }\n  }\n\n  async getBTCBPriceFromPancakeswap(): Promise<string> {\n    const ready = await this.provider.ready;\n    if (!ready) return;\n    const { BTCB } = this.externalTokens;\n    try {\n      const btcPriceInBNB = await this.getTokenPriceFromPancakeswap(BTCB);\n\n      const wbnbPrice = await this.getWBNBPriceFromPancakeswap();\n\n      const btcprice = (Number(btcPriceInBNB) * Number(wbnbPrice)).toFixed(2).toString();\n      //console.log('btcprice', btcprice);\n      return btcprice;\n    } catch (err) {\n      console.error(`Failed to fetch token price of BTCB: ${err}`);\n    }\n  }\n\n  // async getBTCBPriceFromPancakeswap(): Promise<string> {\n  //   const ready = await this.provider.ready;\n  //   if (!ready) return;\n  //   const { BTCB, FUSDT } = this.externalTokens;\n  //   try {\n  //     const fusdt_btcb_lp_pair = this.externalTokens['USDT-BTCB-LP'];\n  //     let ftm_amount_BN = await BTCB.balanceOf(fusdt_btcb_lp_pair.address);\n  //     let ftm_amount = Number(getFullDisplayBalance(ftm_amount_BN, BTCB.decimal));\n  //     let fusdt_amount_BN = await FUSDT.balanceOf(fusdt_btcb_lp_pair.address);\n  //     let fusdt_amount = Number(getFullDisplayBalance(fusdt_amount_BN, FUSDT.decimal));\n  //     console.log('BTCB price', (fusdt_amount / ftm_amount).toString());\n  //     return (fusdt_amount / ftm_amount).toString();\n  //     console.log('BTCB price');\n  //   } catch (err) {\n  //     console.error(`Failed to fetch token price of BTCB: ${err}`);\n  //   }\n  // }\n\n  //===================================================================\n  //===================================================================\n  //===================== MASONRY METHODS =============================\n  //===================================================================\n  //===================================================================\n\n  async getBoardroomAPR() {\n    const Boardroom = this.currentBoardroom();\n    const latestSnapshotIndex = await Boardroom.latestSnapshotIndex();\n    const lastHistory = await Boardroom.boardroomHistory(latestSnapshotIndex);\n\n    const lastRewardsReceived = lastHistory[1];\n\n    const BSHAREPrice = (await this.getShareStat()).priceInDollars;\n    const BOMBPrice = (await this.getBombStat()).priceInDollars;\n    const epochRewardsPerShare = lastRewardsReceived / 1e18;\n\n    //Mgod formula\n    const amountOfRewardsPerDay = epochRewardsPerShare * Number(BOMBPrice) * 4;\n    const boardroomtShareBalanceOf = await this.BSHARE.balanceOf(Boardroom.address);\n    const boardroomTVL = Number(getDisplayBalance(boardroomtShareBalanceOf, this.BSHARE.decimal)) * Number(BSHAREPrice);\n    const realAPR = ((amountOfRewardsPerDay * 100) / boardroomTVL) * 365;\n    return realAPR;\n  }\n\n  async getBombStakeAPR() {\n    const Boardroom = this.currentBoardroom();\n    const latestSnapshotIndex = await Boardroom.latestSnapshotIndex();\n    const lastHistory = await Boardroom.boardroomHistory(latestSnapshotIndex);\n\n    const lastRewardsReceived = lastHistory[1];\n\n    const BOMBPrice = (await this.getBombStat()).priceInDollars;\n    const epochRewardsPerShare = lastRewardsReceived / 1e18;\n\n    //Mgod formula\n    const amountOfRewardsPerDay = epochRewardsPerShare * Number(BOMBPrice) * 4;\n    const xBombBombBalanceOf = await this.BOMB.balanceOf(this.XBOMB.address);\n    const bombTVL = Number(getDisplayBalance(xBombBombBalanceOf, this.XBOMB.decimal)) * Number(BOMBPrice);\n    const realAPR = ((amountOfRewardsPerDay * 100 * 0.2) / bombTVL) * 365;\n    return realAPR;\n  }\n\n  /**\n   * Checks if the user is allowed to retrieve their reward from the Boardroom\n   * @returns true if user can withdraw reward, false if they can't\n   */\n  async canUserClaimRewardFromBoardroom(): Promise<boolean> {\n    const Boardroom = this.currentBoardroom();\n    return await Boardroom.canClaimReward(this.myAccount);\n  }\n\n  /**\n   * Checks if the user is allowed to retrieve their reward from the Boardroom\n   * @returns true if user can withdraw reward, false if they can't\n   */\n  async canUserUnstakeFromBoardroom(): Promise<boolean> {\n    const Boardroom = this.currentBoardroom();\n    const canWithdraw = await Boardroom.canWithdraw(this.myAccount);\n    const stakedAmount = await this.getStakedSharesOnBoardroom();\n    const notStaked = Number(getDisplayBalance(stakedAmount, this.BSHARE.decimal)) === 0;\n    const result = notStaked ? true : canWithdraw;\n    return result;\n  }\n\n  async timeUntilClaimRewardFromBoardroom(): Promise<BigNumber> {\n    // const Boardroom = this.currentBoardroom();\n    // const mason = await Boardroom.masons(this.myAccount);\n    return BigNumber.from(0);\n  }\n\n  async getTotalStakedInBoardroom(): Promise<BigNumber> {\n    const Boardroom = this.currentBoardroom();\n    return await Boardroom.totalSupply();\n  }\n\n  async stakeShareToBoardroom(amount: string): Promise<TransactionResponse> {\n    if (this.isOldBoardroomMember()) {\n      throw new Error(\"you're using old boardroom. please withdraw and deposit the BSHARE again.\");\n    }\n    const Boardroom = this.currentBoardroom();\n    return await Boardroom.stake(decimalToBalance(amount));\n  }\n\n  async stakeToBomb(amount: string): Promise<TransactionResponse> {\n    const Xbomb = this.contracts.xBOMB;\n    return await Xbomb.enter(decimalToBalance(amount));\n  }\n\n  async redeemFromBomb(amount: string): Promise<TransactionResponse> {\n    const BombRouter = this.contracts.BombRouter;\n    const expiry = new Date(Date.now() + 2880);\n    return await BombRouter.redeem(\n      this.BBOMB_BOMB.address,\n      decimalToBalance(amount),\n      this.myAccount,\n      expiry.getTime(),\n      '0x',\n    );\n  }\n\n  async redeemFromBtcb(amount: string): Promise<TransactionResponse> {\n    const BombRouter = this.contracts.BombRouter;\n    const expiry = new Date(Date.now() + 2880);\n    return await BombRouter.redeem(\n      this.BBOMB_BTCB.address,\n      decimalToBalance(amount),\n      this.myAccount,\n      expiry.getTime(),\n      '0x',\n    );\n  }\n  async supplyToBtcb(amount: string): Promise<TransactionResponse> {\n    const BombRouter = this.contracts.BombRouter;\n    const expiry = new Date(Date.now() + 2880);\n    return await BombRouter.mint(this.BBOMB_BTCB.address, decimalToBalance(amount), this.myAccount, expiry.getTime());\n  }\n\n  async supplyToBomb(amount: string): Promise<TransactionResponse> {\n    const BombRouter = this.contracts.BombRouter;\n    const expiry = new Date(Date.now() + 2880);\n    return await BombRouter.mint(this.BBOMB_BOMB.address, decimalToBalance(amount), this.myAccount, expiry.getTime());\n  }\n\n  async getStakedSharesOnBoardroom(): Promise<BigNumber> {\n    const Boardroom = this.currentBoardroom();\n    if (this.boardroomVersionOfUser === 'v1') {\n      return await Boardroom.getShareOf(this.myAccount);\n    }\n    return await Boardroom.balanceOf(this.myAccount);\n  }\n\n  async getStakedBomb(): Promise<BigNumber> {\n    const Xbomb = this.contracts.xBOMB;\n    return await Xbomb.balanceOf(this.myAccount);\n  }\n\n  async getTotalStakedBomb(): Promise<BigNumber> {\n    const Xbomb = this.contracts.xBOMB;\n    const bomb = this.BOMB;\n    return await bomb.balanceOf(Xbomb.address);\n  }\n\n  async getTotalSuppliedBomb(): Promise<BigNumber> {\n    const bbombBomb = this.BOMB_BORROWABLE;\n    // const bomb = this.BOMB;\n    const totalBomb = await bbombBomb.totalBalance();\n    //  const borrowBomb = await bbombBomb.totalBorrows();\n    // const totalSupplied = totalBomb + borrowBomb;\n    return totalBomb;\n  }\n\n  async getTotalSuppliedBtcb(): Promise<BigNumber> {\n    const bbombBomb = this.BTCB_BORROWABLE;\n    // const bomb = this.BOMB;\n    const totalBtcb = await bbombBomb.totalBalance();\n    //const borrowBtcb = await bbombBomb.totalBorrows();\n    //  const totalSupplied = totalBtcb + borrowBtcb;\n    return totalBtcb;\n  }\n\n  async getXbombExchange(): Promise<BigNumber> {\n    const Xbomb = this.contracts.xBOMB;\n    const XbombExchange = await Xbomb.getExchangeRate();\n\n    const xBombPerBomb = parseFloat(XbombExchange) / 1000000000000000000;\n    const xBombRate = xBombPerBomb.toString();\n    return parseUnits(xBombRate, 18);\n  }\n\n  async withdrawFromBomb(amount: string): Promise<TransactionResponse> {\n    const Xbomb = this.contracts.xBOMB;\n    return await Xbomb.leave(decimalToBalance(amount));\n  }\n\n  async getEarningsOnBoardroom(): Promise<BigNumber> {\n    const Boardroom = this.currentBoardroom();\n    if (this.boardroomVersionOfUser === 'v1') {\n      return await Boardroom.getCashEarningsOf(this.myAccount);\n    }\n    return await Boardroom.earned(this.myAccount);\n  }\n\n  async withdrawShareFromBoardroom(amount: string): Promise<TransactionResponse> {\n    const Boardroom = this.currentBoardroom();\n    return await Boardroom.withdraw(decimalToBalance(amount));\n  }\n\n  async harvestCashFromBoardroom(): Promise<TransactionResponse> {\n    const Boardroom = this.currentBoardroom();\n    if (this.boardroomVersionOfUser === 'v1') {\n      return await Boardroom.claimDividends();\n    }\n    return await Boardroom.claimReward();\n  }\n\n  async exitFromBoardroom(): Promise<TransactionResponse> {\n    const Boardroom = this.currentBoardroom();\n    return await Boardroom.exit();\n  }\n\n  async getTreasuryNextAllocationTime(): Promise<AllocationTime> {\n    const { Treasury } = this.contracts;\n    const nextEpochTimestamp: BigNumber = await Treasury.nextEpochPoint();\n    const nextAllocation = new Date(nextEpochTimestamp.mul(1000).toNumber());\n    const prevAllocation = new Date(Date.now());\n\n    return { from: prevAllocation, to: nextAllocation };\n  }\n  /**\n   * This method calculates and returns in a from to to format\n   * the period the user needs to wait before being allowed to claim\n   * their reward from the boardroom\n   * @returns Promise<AllocationTime>\n   */\n  async getUserClaimRewardTime(): Promise<AllocationTime> {\n    const { Boardroom, Treasury } = this.contracts;\n    const nextEpochTimestamp = await Boardroom.nextEpochPoint(); //in unix timestamp\n    const currentEpoch = await Boardroom.epoch();\n    const mason = await Boardroom.members(this.myAccount);\n    const startTimeEpoch = mason.epochTimerStart;\n    const period = await Treasury.PERIOD();\n    const periodInHours = period / 60 / 60; // 6 hours, period is displayed in seconds which is 21600\n    const rewardLockupEpochs = await Boardroom.rewardLockupEpochs();\n    const targetEpochForClaimUnlock = Number(startTimeEpoch) + Number(rewardLockupEpochs);\n\n    const fromDate = new Date(Date.now());\n    if (targetEpochForClaimUnlock - currentEpoch <= 0) {\n      return { from: fromDate, to: fromDate };\n    } else if (targetEpochForClaimUnlock - currentEpoch === 1) {\n      const toDate = new Date(nextEpochTimestamp * 1000);\n      return { from: fromDate, to: toDate };\n    } else {\n      const toDate = new Date(nextEpochTimestamp * 1000);\n      const delta = targetEpochForClaimUnlock - currentEpoch - 1;\n      const endDate = moment(toDate)\n        .add(delta * periodInHours, 'hours')\n        .toDate();\n      return { from: fromDate, to: endDate };\n    }\n  }\n\n  /**\n   * This method calculates and returns in a from to to format\n   * the period the user needs to wait before being allowed to unstake\n   * from the boardroom\n   * @returns Promise<AllocationTime>\n   */\n  async getUserUnstakeTime(): Promise<AllocationTime> {\n    const { Boardroom, Treasury } = this.contracts;\n    const nextEpochTimestamp = await Boardroom.nextEpochPoint();\n    const currentEpoch = await Boardroom.epoch();\n    const mason = await Boardroom.members(this.myAccount);\n    const startTimeEpoch = mason.epochTimerStart;\n    const period = await Treasury.PERIOD();\n    const PeriodInHours = period / 60 / 60;\n    const withdrawLockupEpochs = await Boardroom.withdrawLockupEpochs();\n    const fromDate = new Date(Date.now());\n    const targetEpochForClaimUnlock = Number(startTimeEpoch) + Number(withdrawLockupEpochs);\n    const stakedAmount = await this.getStakedSharesOnBoardroom();\n    if (currentEpoch <= targetEpochForClaimUnlock && Number(stakedAmount) === 0) {\n      return { from: fromDate, to: fromDate };\n    } else if (targetEpochForClaimUnlock - currentEpoch === 1) {\n      const toDate = new Date(nextEpochTimestamp * 1000);\n      return { from: fromDate, to: toDate };\n    } else {\n      const toDate = new Date(nextEpochTimestamp * 1000);\n      const delta = targetEpochForClaimUnlock - Number(currentEpoch) - 1;\n      const endDate = moment(toDate)\n        .add(delta * PeriodInHours, 'hours')\n        .toDate();\n      return { from: fromDate, to: endDate };\n    }\n  }\n\n  async watchAssetInMetamask(assetName: string): Promise<boolean> {\n    const { ethereum } = window as any;\n    if (ethereum && ethereum.networkVersion === config.chainId.toString()) {\n      let asset;\n      let assetUrl;\n      if (assetName === 'BOMB') {\n        asset = this.BOMB;\n        assetUrl = 'https://raw.githubusercontent.com/bombmoney/bomb-assets/master/bomb-512.png';\n      } else if (assetName === 'BSHARE') {\n        asset = this.BSHARE;\n        assetUrl = 'https://raw.githubusercontent.com/bombmoney/bomb-assets/master/bshare-512.png';\n      } else if (assetName === 'BBOND') {\n        asset = this.BBOND;\n        assetUrl = 'https://raw.githubusercontent.com/bombmoney/bomb-assets/master/bbond-512.png';\n      } else if (assetName === 'XBOMB') {\n        asset = this.XBOMB;\n        assetUrl = 'https://raw.githubusercontent.com/bombmoney/bomb-assets/master/xbomb-512.png';\n      } else if (assetName === 'BTCB') {\n        asset = this.BTC;\n        assetUrl = 'https://bscscan.com/token/images/btcb_32.png';\n      }\n      await ethereum.request({\n        method: 'wallet_watchAsset',\n        params: {\n          type: 'ERC20',\n          options: {\n            address: asset.address,\n            symbol: asset.symbol,\n            decimals: 18,\n            image: assetUrl,\n          },\n        },\n      });\n    }\n    return true;\n  }\n\n  async provideBombFtmLP(ftmAmount: string, bombAmount: BigNumber): Promise<TransactionResponse> {\n    const { TaxOffice } = this.contracts;\n    let overrides = {\n      value: parseUnits(ftmAmount, 18),\n    };\n    return await TaxOffice.addLiquidityETHTaxFree(\n      bombAmount,\n      bombAmount.mul(992).div(1000),\n      parseUnits(ftmAmount, 18).mul(992).div(1000),\n      overrides,\n    );\n  }\n\n  async quoteFromSpooky(tokenAmount: string, tokenName: string): Promise<string> {\n    const { SpookyRouter } = this.contracts;\n    const { _reserve0, _reserve1 } = await this.BOMBBTCB_LP.getReserves();\n    let quote;\n    if (tokenName === 'BOMB') {\n      quote = await SpookyRouter.quote(parseUnits(tokenAmount), _reserve0, _reserve1);\n    } else {\n      quote = await SpookyRouter.quote(parseUnits(tokenAmount), _reserve1, _reserve0);\n    }\n    return (quote / 1e18).toString();\n  }\n\n  /**\n   * @returns an array of the regulation events till the most up to date epoch\n   */\n  async listenForRegulationsEvents(): Promise<any> {\n    const { Treasury } = this.contracts;\n\n    const treasuryDaoFundedFilter = Treasury.filters.DaoFundFunded();\n    const treasuryDevFundedFilter = Treasury.filters.DevFundFunded();\n    const treasuryBoardroomFundedFilter = Treasury.filters.BoardroomFunded();\n    const boughtBondsFilter = Treasury.filters.BoughtBonds();\n    const redeemBondsFilter = Treasury.filters.RedeemedBonds();\n\n    let epochBlocksRanges: any[] = [];\n    let boardroomFundEvents = await Treasury.queryFilter(treasuryBoardroomFundedFilter);\n    var events: any[] = [];\n    boardroomFundEvents.forEach(function callback(value, index) {\n      events.push({ epoch: index + 1 });\n      events[index].boardroomFund = getDisplayBalance(value.args[1]);\n      if (index === 0) {\n        epochBlocksRanges.push({\n          index: index,\n          startBlock: value.blockNumber,\n          boughBonds: 0,\n          redeemedBonds: 0,\n        });\n      }\n      if (index > 0) {\n        epochBlocksRanges.push({\n          index: index,\n          startBlock: value.blockNumber,\n          boughBonds: 0,\n          redeemedBonds: 0,\n        });\n        epochBlocksRanges[index - 1].endBlock = value.blockNumber;\n      }\n    });\n\n    epochBlocksRanges.forEach(async (value, index) => {\n      events[index].bondsBought = await this.getBondsWithFilterForPeriod(\n        boughtBondsFilter,\n        value.startBlock,\n        value.endBlock,\n      );\n      events[index].bondsRedeemed = await this.getBondsWithFilterForPeriod(\n        redeemBondsFilter,\n        value.startBlock,\n        value.endBlock,\n      );\n    });\n    let DEVFundEvents = await Treasury.queryFilter(treasuryDevFundedFilter);\n    DEVFundEvents.forEach(function callback(value, index) {\n      events[index].devFund = getDisplayBalance(value.args[1]);\n    });\n    let DAOFundEvents = await Treasury.queryFilter(treasuryDaoFundedFilter);\n    DAOFundEvents.forEach(function callback(value, index) {\n      events[index].daoFund = getDisplayBalance(value.args[1]);\n    });\n    return events;\n  }\n\n  /**\n   * Helper method\n   * @param filter applied on the query to the treasury events\n   * @param from block number\n   * @param to block number\n   * @returns the amount of bonds events emitted based on the filter provided during a specific period\n   */\n  async getBondsWithFilterForPeriod(filter: EventFilter, from: number, to: number): Promise<number> {\n    const { Treasury } = this.contracts;\n    const bondsAmount = await Treasury.queryFilter(filter, from, to);\n    return bondsAmount.length;\n  }\n\n  async estimateZapIn(tokenName: string, lpName: string, amount: string): Promise<number[]> {\n    const { zapper } = this.contracts;\n    const lpToken = this.externalTokens[lpName];\n    let estimate;\n    if (tokenName === BNB_TICKER) {\n      estimate = await zapper.estimateZapIn(lpToken.address, SPOOKY_ROUTER_ADDR, parseUnits(amount, 18));\n    } else {\n      const token = tokenName === BOMB_TICKER ? this.BOMB : this.BSHARE;\n      estimate = await zapper.estimateZapInToken(\n        token.address,\n        lpToken.address,\n        SPOOKY_ROUTER_ADDR,\n        parseUnits(amount, 18),\n      );\n    }\n    return [estimate[0] / 1e18, estimate[1] / 1e18];\n  }\n  async zapIn(tokenName: string, lpName: string, amount: string): Promise<TransactionResponse> {\n    const { zapper } = this.contracts;\n    const lpToken = this.externalTokens[lpName];\n    if (tokenName === BNB_TICKER) {\n      let overrides = {\n        value: parseUnits(amount, 18),\n      };\n      return await zapper.zapIn(lpToken.address, SPOOKY_ROUTER_ADDR, this.myAccount, overrides);\n    } else {\n      const token = tokenName === BOMB_TICKER ? this.BOMB : this.BSHARE;\n      return await zapper.zapInToken(\n        token.address,\n        parseUnits(amount, 18),\n        lpToken.address,\n        SPOOKY_ROUTER_ADDR,\n        this.myAccount,\n      );\n    }\n  }\n  async swapBBondToBShare(bbondAmount: BigNumber): Promise<TransactionResponse> {\n    const { BShareSwapper } = this.contracts;\n    return await BShareSwapper.swapBBondToBShare(bbondAmount);\n  }\n  async estimateAmountOfBShare(bbondAmount: string): Promise<string> {\n    const { BShareSwapper } = this.contracts;\n    try {\n      const estimateBN = await BShareSwapper.estimateAmountOfBShare(parseUnits(bbondAmount, 18));\n      return getDisplayBalance(estimateBN, 18, 6);\n    } catch (err) {\n      console.error(`Failed to fetch estimate bshare amount: ${err}`);\n    }\n  }\n\n  async getBShareSwapperStat(address: string): Promise<BShareSwapperStat> {\n    const { BShareSwapper } = this.contracts;\n    const bshareBalanceBN = await BShareSwapper.getBShareBalance();\n    const bbondBalanceBN = await BShareSwapper.getBBondBalance(address);\n    // const bombPriceBN = await BShareSwapper.getBombPrice();\n    // const bsharePriceBN = await BShareSwapper.getBSharePrice();\n    const rateBSharePerBombBN = await BShareSwapper.getBShareAmountPerBomb();\n    const bshareBalance = getDisplayBalance(bshareBalanceBN, 18, 5);\n    const bbondBalance = getDisplayBalance(bbondBalanceBN, 18, 5);\n    return {\n      bshareBalance: bshareBalance.toString(),\n      bbondBalance: bbondBalance.toString(),\n      // bombPrice: bombPriceBN.toString(),\n      // bsharePrice: bsharePriceBN.toString(),\n      rateBSharePerBomb: rateBSharePerBombBN.toString(),\n    };\n  }\n}\n"]},"metadata":{},"sourceType":"module"}