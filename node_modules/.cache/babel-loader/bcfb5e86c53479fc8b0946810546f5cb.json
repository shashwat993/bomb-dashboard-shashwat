{"ast":null,"code":"'use strict';\n\nvar helpers = require('./helpers');\n/** @type ValidatorResult */\n\n\nvar ValidatorResult = helpers.ValidatorResult;\n/** @type SchemaError */\n\nvar SchemaError = helpers.SchemaError;\nvar attribute = {};\nattribute.ignoreProperties = {\n  // informative properties\n  'id': true,\n  'default': true,\n  'description': true,\n  'title': true,\n  // arguments to other properties\n  'additionalItems': true,\n  'then': true,\n  'else': true,\n  // special-handled properties\n  '$schema': true,\n  '$ref': true,\n  'extends': true\n};\n/**\n * @name validators\n */\n\nvar validators = attribute.validators = {};\n/**\n * Validates whether the instance if of a certain type\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {ValidatorResult|null}\n */\n\nvalidators.type = function validateType(instance, schema, options, ctx) {\n  // Ignore undefined instances\n  if (instance === undefined) {\n    return null;\n  }\n\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var types = Array.isArray(schema.type) ? schema.type : [schema.type];\n\n  if (!types.some(this.testType.bind(this, instance, schema, options, ctx))) {\n    var list = types.map(function (v) {\n      if (!v) return;\n      var id = v.$id || v.id;\n      return id ? '<' + id + '>' : v + '';\n    });\n    result.addError({\n      name: 'type',\n      argument: list,\n      message: \"is not of a type(s) \" + list\n    });\n  }\n\n  return result;\n};\n\nfunction testSchemaNoThrow(instance, options, ctx, callback, schema) {\n  var throwError = options.throwError;\n  var throwAll = options.throwAll;\n  options.throwError = false;\n  options.throwAll = false;\n  var res = this.validateSchema(instance, schema, options, ctx);\n  options.throwError = throwError;\n  options.throwAll = throwAll;\n\n  if (!res.valid && callback instanceof Function) {\n    callback(res);\n  }\n\n  return res.valid;\n}\n/**\n * Validates whether the instance matches some of the given schemas\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {ValidatorResult|null}\n */\n\n\nvalidators.anyOf = function validateAnyOf(instance, schema, options, ctx) {\n  // Ignore undefined instances\n  if (instance === undefined) {\n    return null;\n  }\n\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var inner = new ValidatorResult(instance, schema, options, ctx);\n\n  if (!Array.isArray(schema.anyOf)) {\n    throw new SchemaError(\"anyOf must be an array\");\n  }\n\n  if (!schema.anyOf.some(testSchemaNoThrow.bind(this, instance, options, ctx, function (res) {\n    inner.importErrors(res);\n  }))) {\n    var list = schema.anyOf.map(function (v, i) {\n      var id = v.$id || v.id;\n      if (id) return '<' + id + '>';\n      return v.title && JSON.stringify(v.title) || v['$ref'] && '<' + v['$ref'] + '>' || '[subschema ' + i + ']';\n    });\n\n    if (options.nestedErrors) {\n      result.importErrors(inner);\n    }\n\n    result.addError({\n      name: 'anyOf',\n      argument: list,\n      message: \"is not any of \" + list.join(',')\n    });\n  }\n\n  return result;\n};\n/**\n * Validates whether the instance matches every given schema\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {String|null}\n */\n\n\nvalidators.allOf = function validateAllOf(instance, schema, options, ctx) {\n  // Ignore undefined instances\n  if (instance === undefined) {\n    return null;\n  }\n\n  if (!Array.isArray(schema.allOf)) {\n    throw new SchemaError(\"allOf must be an array\");\n  }\n\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var self = this;\n  schema.allOf.forEach(function (v, i) {\n    var valid = self.validateSchema(instance, v, options, ctx);\n\n    if (!valid.valid) {\n      var id = v.$id || v.id;\n      var msg = id || v.title && JSON.stringify(v.title) || v['$ref'] && '<' + v['$ref'] + '>' || '[subschema ' + i + ']';\n      result.addError({\n        name: 'allOf',\n        argument: {\n          id: msg,\n          length: valid.errors.length,\n          valid: valid\n        },\n        message: 'does not match allOf schema ' + msg + ' with ' + valid.errors.length + ' error[s]:'\n      });\n      result.importErrors(valid);\n    }\n  });\n  return result;\n};\n/**\n * Validates whether the instance matches exactly one of the given schemas\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {String|null}\n */\n\n\nvalidators.oneOf = function validateOneOf(instance, schema, options, ctx) {\n  // Ignore undefined instances\n  if (instance === undefined) {\n    return null;\n  }\n\n  if (!Array.isArray(schema.oneOf)) {\n    throw new SchemaError(\"oneOf must be an array\");\n  }\n\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var inner = new ValidatorResult(instance, schema, options, ctx);\n  var count = schema.oneOf.filter(testSchemaNoThrow.bind(this, instance, options, ctx, function (res) {\n    inner.importErrors(res);\n  })).length;\n  var list = schema.oneOf.map(function (v, i) {\n    var id = v.$id || v.id;\n    return id || v.title && JSON.stringify(v.title) || v['$ref'] && '<' + v['$ref'] + '>' || '[subschema ' + i + ']';\n  });\n\n  if (count !== 1) {\n    if (options.nestedErrors) {\n      result.importErrors(inner);\n    }\n\n    result.addError({\n      name: 'oneOf',\n      argument: list,\n      message: \"is not exactly one from \" + list.join(',')\n    });\n  }\n\n  return result;\n};\n/**\n * Validates \"then\" or \"else\" depending on the result of validating \"if\"\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {String|null}\n */\n\n\nvalidators.if = function validateIf(instance, schema, options, ctx) {\n  // Ignore undefined instances\n  if (instance === undefined) return null;\n  if (!helpers.isSchema(schema.if)) throw new Error('Expected \"if\" keyword to be a schema');\n  var ifValid = testSchemaNoThrow.call(this, instance, options, ctx, null, schema.if);\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var res;\n\n  if (ifValid) {\n    if (schema.then === undefined) return;\n    if (!helpers.isSchema(schema.then)) throw new Error('Expected \"then\" keyword to be a schema');\n    res = this.validateSchema(instance, schema.then, options, ctx.makeChild(schema.then));\n    result.importErrors(res);\n  } else {\n    if (schema.else === undefined) return;\n    if (!helpers.isSchema(schema.else)) throw new Error('Expected \"else\" keyword to be a schema');\n    res = this.validateSchema(instance, schema.else, options, ctx.makeChild(schema.else));\n    result.importErrors(res);\n  }\n\n  return result;\n};\n\nfunction getEnumerableProperty(object, key) {\n  // Determine if `key` shows up in `for(var key in object)`\n  // First test Object.hasOwnProperty.call as an optimization: that guarantees it does\n  if (Object.hasOwnProperty.call(object, key)) return object[key]; // Test `key in object` as an optimization; false means it won't\n\n  if (!(key in object)) return;\n\n  while (object = Object.getPrototypeOf(object)) {\n    if (Object.propertyIsEnumerable.call(object, key)) return object[key];\n  }\n}\n/**\n * Validates propertyNames\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {String|null|ValidatorResult}\n */\n\n\nvalidators.propertyNames = function validatePropertyNames(instance, schema, options, ctx) {\n  if (!this.types.object(instance)) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var subschema = schema.propertyNames !== undefined ? schema.propertyNames : {};\n  if (!helpers.isSchema(subschema)) throw new SchemaError('Expected \"propertyNames\" to be a schema (object or boolean)');\n\n  for (var property in instance) {\n    if (getEnumerableProperty(instance, property) !== undefined) {\n      var res = this.validateSchema(property, subschema, options, ctx.makeChild(subschema));\n      result.importErrors(res);\n    }\n  }\n\n  return result;\n};\n/**\n * Validates properties\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {String|null|ValidatorResult}\n */\n\n\nvalidators.properties = function validateProperties(instance, schema, options, ctx) {\n  if (!this.types.object(instance)) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var properties = schema.properties || {};\n\n  for (var property in properties) {\n    var subschema = properties[property];\n\n    if (subschema === undefined) {\n      continue;\n    } else if (subschema === null) {\n      throw new SchemaError('Unexpected null, expected schema in \"properties\"');\n    }\n\n    if (typeof options.preValidateProperty == 'function') {\n      options.preValidateProperty(instance, property, subschema, options, ctx);\n    }\n\n    var prop = getEnumerableProperty(instance, property);\n    var res = this.validateSchema(prop, subschema, options, ctx.makeChild(subschema, property));\n    if (res.instance !== result.instance[property]) result.instance[property] = res.instance;\n    result.importErrors(res);\n  }\n\n  return result;\n};\n/**\n * Test a specific property within in instance against the additionalProperties schema attribute\n * This ignores properties with definitions in the properties schema attribute, but no other attributes.\n * If too many more types of property-existence tests pop up they may need their own class of tests (like `type` has)\n * @private\n * @return {boolean}\n */\n\n\nfunction testAdditionalProperty(instance, schema, options, ctx, property, result) {\n  if (!this.types.object(instance)) return;\n\n  if (schema.properties && schema.properties[property] !== undefined) {\n    return;\n  }\n\n  if (schema.additionalProperties === false) {\n    result.addError({\n      name: 'additionalProperties',\n      argument: property,\n      message: \"is not allowed to have the additional property \" + JSON.stringify(property)\n    });\n  } else {\n    var additionalProperties = schema.additionalProperties || {};\n\n    if (typeof options.preValidateProperty == 'function') {\n      options.preValidateProperty(instance, property, additionalProperties, options, ctx);\n    }\n\n    var res = this.validateSchema(instance[property], additionalProperties, options, ctx.makeChild(additionalProperties, property));\n    if (res.instance !== result.instance[property]) result.instance[property] = res.instance;\n    result.importErrors(res);\n  }\n}\n/**\n * Validates patternProperties\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {String|null|ValidatorResult}\n */\n\n\nvalidators.patternProperties = function validatePatternProperties(instance, schema, options, ctx) {\n  if (!this.types.object(instance)) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var patternProperties = schema.patternProperties || {};\n\n  for (var property in instance) {\n    var test = true;\n\n    for (var pattern in patternProperties) {\n      var subschema = patternProperties[pattern];\n\n      if (subschema === undefined) {\n        continue;\n      } else if (subschema === null) {\n        throw new SchemaError('Unexpected null, expected schema in \"patternProperties\"');\n      }\n\n      try {\n        var regexp = new RegExp(pattern, 'u');\n      } catch (_e) {\n        // In the event the stricter handling causes an error, fall back on the forgiving handling\n        // DEPRECATED\n        regexp = new RegExp(pattern);\n      }\n\n      if (!regexp.test(property)) {\n        continue;\n      }\n\n      test = false;\n\n      if (typeof options.preValidateProperty == 'function') {\n        options.preValidateProperty(instance, property, subschema, options, ctx);\n      }\n\n      var res = this.validateSchema(instance[property], subschema, options, ctx.makeChild(subschema, property));\n      if (res.instance !== result.instance[property]) result.instance[property] = res.instance;\n      result.importErrors(res);\n    }\n\n    if (test) {\n      testAdditionalProperty.call(this, instance, schema, options, ctx, property, result);\n    }\n  }\n\n  return result;\n};\n/**\n * Validates additionalProperties\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {String|null|ValidatorResult}\n */\n\n\nvalidators.additionalProperties = function validateAdditionalProperties(instance, schema, options, ctx) {\n  if (!this.types.object(instance)) return; // if patternProperties is defined then we'll test when that one is called instead\n\n  if (schema.patternProperties) {\n    return null;\n  }\n\n  var result = new ValidatorResult(instance, schema, options, ctx);\n\n  for (var property in instance) {\n    testAdditionalProperty.call(this, instance, schema, options, ctx, property, result);\n  }\n\n  return result;\n};\n/**\n * Validates whether the instance value is at least of a certain length, when the instance value is a string.\n * @param instance\n * @param schema\n * @return {String|null}\n */\n\n\nvalidators.minProperties = function validateMinProperties(instance, schema, options, ctx) {\n  if (!this.types.object(instance)) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var keys = Object.keys(instance);\n\n  if (!(keys.length >= schema.minProperties)) {\n    result.addError({\n      name: 'minProperties',\n      argument: schema.minProperties,\n      message: \"does not meet minimum property length of \" + schema.minProperties\n    });\n  }\n\n  return result;\n};\n/**\n * Validates whether the instance value is at most of a certain length, when the instance value is a string.\n * @param instance\n * @param schema\n * @return {String|null}\n */\n\n\nvalidators.maxProperties = function validateMaxProperties(instance, schema, options, ctx) {\n  if (!this.types.object(instance)) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var keys = Object.keys(instance);\n\n  if (!(keys.length <= schema.maxProperties)) {\n    result.addError({\n      name: 'maxProperties',\n      argument: schema.maxProperties,\n      message: \"does not meet maximum property length of \" + schema.maxProperties\n    });\n  }\n\n  return result;\n};\n/**\n * Validates items when instance is an array\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {String|null|ValidatorResult}\n */\n\n\nvalidators.items = function validateItems(instance, schema, options, ctx) {\n  var self = this;\n  if (!this.types.array(instance)) return;\n  if (!schema.items) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  instance.every(function (value, i) {\n    var items = Array.isArray(schema.items) ? schema.items[i] || schema.additionalItems : schema.items;\n\n    if (items === undefined) {\n      return true;\n    }\n\n    if (items === false) {\n      result.addError({\n        name: 'items',\n        message: \"additionalItems not permitted\"\n      });\n      return false;\n    }\n\n    var res = self.validateSchema(value, items, options, ctx.makeChild(items, i));\n    if (res.instance !== result.instance[i]) result.instance[i] = res.instance;\n    result.importErrors(res);\n    return true;\n  });\n  return result;\n};\n/**\n * Validates minimum and exclusiveMinimum when the type of the instance value is a number.\n * @param instance\n * @param schema\n * @return {String|null}\n */\n\n\nvalidators.minimum = function validateMinimum(instance, schema, options, ctx) {\n  if (!this.types.number(instance)) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n\n  if (schema.exclusiveMinimum && schema.exclusiveMinimum === true) {\n    if (!(instance > schema.minimum)) {\n      result.addError({\n        name: 'minimum',\n        argument: schema.minimum,\n        message: \"must be greater than \" + schema.minimum\n      });\n    }\n  } else {\n    if (!(instance >= schema.minimum)) {\n      result.addError({\n        name: 'minimum',\n        argument: schema.minimum,\n        message: \"must be greater than or equal to \" + schema.minimum\n      });\n    }\n  }\n\n  return result;\n};\n/**\n * Validates maximum and exclusiveMaximum when the type of the instance value is a number.\n * @param instance\n * @param schema\n * @return {String|null}\n */\n\n\nvalidators.maximum = function validateMaximum(instance, schema, options, ctx) {\n  if (!this.types.number(instance)) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n\n  if (schema.exclusiveMaximum && schema.exclusiveMaximum === true) {\n    if (!(instance < schema.maximum)) {\n      result.addError({\n        name: 'maximum',\n        argument: schema.maximum,\n        message: \"must be less than \" + schema.maximum\n      });\n    }\n  } else {\n    if (!(instance <= schema.maximum)) {\n      result.addError({\n        name: 'maximum',\n        argument: schema.maximum,\n        message: \"must be less than or equal to \" + schema.maximum\n      });\n    }\n  }\n\n  return result;\n};\n/**\n * Validates the number form of exclusiveMinimum when the type of the instance value is a number.\n * @param instance\n * @param schema\n * @return {String|null}\n */\n\n\nvalidators.exclusiveMinimum = function validateExclusiveMinimum(instance, schema, options, ctx) {\n  // Support the boolean form of exclusiveMinimum, which is handled by the \"minimum\" keyword.\n  if (typeof schema.exclusiveMaximum === 'boolean') return;\n  if (!this.types.number(instance)) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var valid = instance > schema.exclusiveMinimum;\n\n  if (!valid) {\n    result.addError({\n      name: 'exclusiveMinimum',\n      argument: schema.exclusiveMinimum,\n      message: \"must be strictly greater than \" + schema.exclusiveMinimum\n    });\n  }\n\n  return result;\n};\n/**\n * Validates the number form of exclusiveMaximum when the type of the instance value is a number.\n * @param instance\n * @param schema\n * @return {String|null}\n */\n\n\nvalidators.exclusiveMaximum = function validateExclusiveMaximum(instance, schema, options, ctx) {\n  // Support the boolean form of exclusiveMaximum, which is handled by the \"maximum\" keyword.\n  if (typeof schema.exclusiveMaximum === 'boolean') return;\n  if (!this.types.number(instance)) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var valid = instance < schema.exclusiveMaximum;\n\n  if (!valid) {\n    result.addError({\n      name: 'exclusiveMaximum',\n      argument: schema.exclusiveMaximum,\n      message: \"must be strictly less than \" + schema.exclusiveMaximum\n    });\n  }\n\n  return result;\n};\n/**\n * Perform validation for multipleOf and divisibleBy, which are essentially the same.\n * @param instance\n * @param schema\n * @param validationType\n * @param errorMessage\n * @returns {String|null}\n */\n\n\nvar validateMultipleOfOrDivisbleBy = function validateMultipleOfOrDivisbleBy(instance, schema, options, ctx, validationType, errorMessage) {\n  if (!this.types.number(instance)) return;\n  var validationArgument = schema[validationType];\n\n  if (validationArgument == 0) {\n    throw new SchemaError(validationType + \" cannot be zero\");\n  }\n\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var instanceDecimals = helpers.getDecimalPlaces(instance);\n  var divisorDecimals = helpers.getDecimalPlaces(validationArgument);\n  var maxDecimals = Math.max(instanceDecimals, divisorDecimals);\n  var multiplier = Math.pow(10, maxDecimals);\n\n  if (Math.round(instance * multiplier) % Math.round(validationArgument * multiplier) !== 0) {\n    result.addError({\n      name: validationType,\n      argument: validationArgument,\n      message: errorMessage + JSON.stringify(validationArgument)\n    });\n  }\n\n  return result;\n};\n/**\n * Validates divisibleBy when the type of the instance value is a number.\n * @param instance\n * @param schema\n * @return {String|null}\n */\n\n\nvalidators.multipleOf = function validateMultipleOf(instance, schema, options, ctx) {\n  return validateMultipleOfOrDivisbleBy.call(this, instance, schema, options, ctx, \"multipleOf\", \"is not a multiple of (divisible by) \");\n};\n/**\n * Validates multipleOf when the type of the instance value is a number.\n * @param instance\n * @param schema\n * @return {String|null}\n */\n\n\nvalidators.divisibleBy = function validateDivisibleBy(instance, schema, options, ctx) {\n  return validateMultipleOfOrDivisbleBy.call(this, instance, schema, options, ctx, \"divisibleBy\", \"is not divisible by (multiple of) \");\n};\n/**\n * Validates whether the instance value is present.\n * @param instance\n * @param schema\n * @return {String|null}\n */\n\n\nvalidators.required = function validateRequired(instance, schema, options, ctx) {\n  var result = new ValidatorResult(instance, schema, options, ctx);\n\n  if (instance === undefined && schema.required === true) {\n    // A boolean form is implemented for reverse-compatibility with schemas written against older drafts\n    result.addError({\n      name: 'required',\n      message: \"is required\"\n    });\n  } else if (this.types.object(instance) && Array.isArray(schema.required)) {\n    schema.required.forEach(function (n) {\n      if (getEnumerableProperty(instance, n) === undefined) {\n        result.addError({\n          name: 'required',\n          argument: n,\n          message: \"requires property \" + JSON.stringify(n)\n        });\n      }\n    });\n  }\n\n  return result;\n};\n/**\n * Validates whether the instance value matches the regular expression, when the instance value is a string.\n * @param instance\n * @param schema\n * @return {String|null}\n */\n\n\nvalidators.pattern = function validatePattern(instance, schema, options, ctx) {\n  if (!this.types.string(instance)) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var pattern = schema.pattern;\n\n  try {\n    var regexp = new RegExp(pattern, 'u');\n  } catch (_e) {\n    // In the event the stricter handling causes an error, fall back on the forgiving handling\n    // DEPRECATED\n    regexp = new RegExp(pattern);\n  }\n\n  if (!instance.match(regexp)) {\n    result.addError({\n      name: 'pattern',\n      argument: schema.pattern,\n      message: \"does not match pattern \" + JSON.stringify(schema.pattern.toString())\n    });\n  }\n\n  return result;\n};\n/**\n * Validates whether the instance value is of a certain defined format or a custom\n * format.\n * The following formats are supported for string types:\n *   - date-time\n *   - date\n *   - time\n *   - ip-address\n *   - ipv6\n *   - uri\n *   - color\n *   - host-name\n *   - alpha\n *   - alpha-numeric\n *   - utc-millisec\n * @param instance\n * @param schema\n * @param [options]\n * @param [ctx]\n * @return {String|null}\n */\n\n\nvalidators.format = function validateFormat(instance, schema, options, ctx) {\n  if (instance === undefined) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n\n  if (!result.disableFormat && !helpers.isFormat(instance, schema.format, this)) {\n    result.addError({\n      name: 'format',\n      argument: schema.format,\n      message: \"does not conform to the \" + JSON.stringify(schema.format) + \" format\"\n    });\n  }\n\n  return result;\n};\n/**\n * Validates whether the instance value is at least of a certain length, when the instance value is a string.\n * @param instance\n * @param schema\n * @return {String|null}\n */\n\n\nvalidators.minLength = function validateMinLength(instance, schema, options, ctx) {\n  if (!this.types.string(instance)) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var hsp = instance.match(/[\\uDC00-\\uDFFF]/g);\n  var length = instance.length - (hsp ? hsp.length : 0);\n\n  if (!(length >= schema.minLength)) {\n    result.addError({\n      name: 'minLength',\n      argument: schema.minLength,\n      message: \"does not meet minimum length of \" + schema.minLength\n    });\n  }\n\n  return result;\n};\n/**\n * Validates whether the instance value is at most of a certain length, when the instance value is a string.\n * @param instance\n * @param schema\n * @return {String|null}\n */\n\n\nvalidators.maxLength = function validateMaxLength(instance, schema, options, ctx) {\n  if (!this.types.string(instance)) return;\n  var result = new ValidatorResult(instance, schema, options, ctx); // TODO if this was already computed in \"minLength\", use that value instead of re-computing\n\n  var hsp = instance.match(/[\\uDC00-\\uDFFF]/g);\n  var length = instance.length - (hsp ? hsp.length : 0);\n\n  if (!(length <= schema.maxLength)) {\n    result.addError({\n      name: 'maxLength',\n      argument: schema.maxLength,\n      message: \"does not meet maximum length of \" + schema.maxLength\n    });\n  }\n\n  return result;\n};\n/**\n * Validates whether instance contains at least a minimum number of items, when the instance is an Array.\n * @param instance\n * @param schema\n * @return {String|null}\n */\n\n\nvalidators.minItems = function validateMinItems(instance, schema, options, ctx) {\n  if (!this.types.array(instance)) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n\n  if (!(instance.length >= schema.minItems)) {\n    result.addError({\n      name: 'minItems',\n      argument: schema.minItems,\n      message: \"does not meet minimum length of \" + schema.minItems\n    });\n  }\n\n  return result;\n};\n/**\n * Validates whether instance contains no more than a maximum number of items, when the instance is an Array.\n * @param instance\n * @param schema\n * @return {String|null}\n */\n\n\nvalidators.maxItems = function validateMaxItems(instance, schema, options, ctx) {\n  if (!this.types.array(instance)) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n\n  if (!(instance.length <= schema.maxItems)) {\n    result.addError({\n      name: 'maxItems',\n      argument: schema.maxItems,\n      message: \"does not meet maximum length of \" + schema.maxItems\n    });\n  }\n\n  return result;\n};\n/**\n * Deep compares arrays for duplicates\n * @param v\n * @param i\n * @param a\n * @private\n * @return {boolean}\n */\n\n\nfunction testArrays(v, i, a) {\n  var j,\n      len = a.length;\n\n  for (j = i + 1, len; j < len; j++) {\n    if (helpers.deepCompareStrict(v, a[j])) {\n      return false;\n    }\n  }\n\n  return true;\n}\n/**\n * Validates whether there are no duplicates, when the instance is an Array.\n * @param instance\n * @return {String|null}\n */\n\n\nvalidators.uniqueItems = function validateUniqueItems(instance, schema, options, ctx) {\n  if (schema.uniqueItems !== true) return;\n  if (!this.types.array(instance)) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n\n  if (!instance.every(testArrays)) {\n    result.addError({\n      name: 'uniqueItems',\n      message: \"contains duplicate item\"\n    });\n  }\n\n  return result;\n};\n/**\n * Validate for the presence of dependency properties, if the instance is an object.\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {null|ValidatorResult}\n */\n\n\nvalidators.dependencies = function validateDependencies(instance, schema, options, ctx) {\n  if (!this.types.object(instance)) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n\n  for (var property in schema.dependencies) {\n    if (instance[property] === undefined) {\n      continue;\n    }\n\n    var dep = schema.dependencies[property];\n    var childContext = ctx.makeChild(dep, property);\n\n    if (typeof dep == 'string') {\n      dep = [dep];\n    }\n\n    if (Array.isArray(dep)) {\n      dep.forEach(function (prop) {\n        if (instance[prop] === undefined) {\n          result.addError({\n            // FIXME there's two different \"dependencies\" errors here with slightly different outputs\n            // Can we make these the same? Or should we create different error types?\n            name: 'dependencies',\n            argument: childContext.propertyPath,\n            message: \"property \" + prop + \" not found, required by \" + childContext.propertyPath\n          });\n        }\n      });\n    } else {\n      var res = this.validateSchema(instance, dep, options, childContext);\n      if (result.instance !== res.instance) result.instance = res.instance;\n\n      if (res && res.errors.length) {\n        result.addError({\n          name: 'dependencies',\n          argument: childContext.propertyPath,\n          message: \"does not meet dependency required by \" + childContext.propertyPath\n        });\n        result.importErrors(res);\n      }\n    }\n  }\n\n  return result;\n};\n/**\n * Validates whether the instance value is one of the enumerated values.\n *\n * @param instance\n * @param schema\n * @return {ValidatorResult|null}\n */\n\n\nvalidators['enum'] = function validateEnum(instance, schema, options, ctx) {\n  if (instance === undefined) {\n    return null;\n  }\n\n  if (!Array.isArray(schema['enum'])) {\n    throw new SchemaError(\"enum expects an array\", schema);\n  }\n\n  var result = new ValidatorResult(instance, schema, options, ctx);\n\n  if (!schema['enum'].some(helpers.deepCompareStrict.bind(null, instance))) {\n    result.addError({\n      name: 'enum',\n      argument: schema['enum'],\n      message: \"is not one of enum values: \" + schema['enum'].map(String).join(',')\n    });\n  }\n\n  return result;\n};\n/**\n * Validates whether the instance exactly matches a given value\n *\n * @param instance\n * @param schema\n * @return {ValidatorResult|null}\n */\n\n\nvalidators['const'] = function validateEnum(instance, schema, options, ctx) {\n  if (instance === undefined) {\n    return null;\n  }\n\n  var result = new ValidatorResult(instance, schema, options, ctx);\n\n  if (!helpers.deepCompareStrict(schema['const'], instance)) {\n    result.addError({\n      name: 'const',\n      argument: schema['const'],\n      message: \"does not exactly match expected constant: \" + schema['const']\n    });\n  }\n\n  return result;\n};\n/**\n * Validates whether the instance if of a prohibited type.\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {null|ValidatorResult}\n */\n\n\nvalidators.not = validators.disallow = function validateNot(instance, schema, options, ctx) {\n  var self = this;\n  if (instance === undefined) return null;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var notTypes = schema.not || schema.disallow;\n  if (!notTypes) return null;\n  if (!Array.isArray(notTypes)) notTypes = [notTypes];\n  notTypes.forEach(function (type) {\n    if (self.testType(instance, schema, options, ctx, type)) {\n      var id = type && (type.$id || type.id);\n      var schemaId = id || type;\n      result.addError({\n        name: 'not',\n        argument: schemaId,\n        message: \"is of prohibited type \" + schemaId\n      });\n    }\n  });\n  return result;\n};\n\nmodule.exports = attribute;","map":{"version":3,"sources":["/home/shashwat/Projects/Intern/node_modules/jsonschema/lib/attribute.js"],"names":["helpers","require","ValidatorResult","SchemaError","attribute","ignoreProperties","validators","type","validateType","instance","schema","options","ctx","undefined","result","types","Array","isArray","some","testType","bind","list","map","v","id","$id","addError","name","argument","message","testSchemaNoThrow","callback","throwError","throwAll","res","validateSchema","valid","Function","anyOf","validateAnyOf","inner","importErrors","i","title","JSON","stringify","nestedErrors","join","allOf","validateAllOf","self","forEach","msg","length","errors","oneOf","validateOneOf","count","filter","if","validateIf","isSchema","Error","ifValid","call","then","makeChild","else","getEnumerableProperty","object","key","Object","hasOwnProperty","getPrototypeOf","propertyIsEnumerable","propertyNames","validatePropertyNames","subschema","property","properties","validateProperties","preValidateProperty","prop","testAdditionalProperty","additionalProperties","patternProperties","validatePatternProperties","test","pattern","regexp","RegExp","_e","validateAdditionalProperties","minProperties","validateMinProperties","keys","maxProperties","validateMaxProperties","items","validateItems","array","every","value","additionalItems","minimum","validateMinimum","number","exclusiveMinimum","maximum","validateMaximum","exclusiveMaximum","validateExclusiveMinimum","validateExclusiveMaximum","validateMultipleOfOrDivisbleBy","validationType","errorMessage","validationArgument","instanceDecimals","getDecimalPlaces","divisorDecimals","maxDecimals","Math","max","multiplier","pow","round","multipleOf","validateMultipleOf","divisibleBy","validateDivisibleBy","required","validateRequired","n","validatePattern","string","match","toString","format","validateFormat","disableFormat","isFormat","minLength","validateMinLength","hsp","maxLength","validateMaxLength","minItems","validateMinItems","maxItems","validateMaxItems","testArrays","a","j","len","deepCompareStrict","uniqueItems","validateUniqueItems","dependencies","validateDependencies","dep","childContext","propertyPath","validateEnum","String","not","disallow","validateNot","notTypes","schemaId","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nvar helpers = require('./helpers');\n\n/** @type ValidatorResult */\nvar ValidatorResult = helpers.ValidatorResult;\n/** @type SchemaError */\nvar SchemaError = helpers.SchemaError;\n\nvar attribute = {};\n\nattribute.ignoreProperties = {\n  // informative properties\n  'id': true,\n  'default': true,\n  'description': true,\n  'title': true,\n  // arguments to other properties\n  'additionalItems': true,\n  'then': true,\n  'else': true,\n  // special-handled properties\n  '$schema': true,\n  '$ref': true,\n  'extends': true,\n};\n\n/**\n * @name validators\n */\nvar validators = attribute.validators = {};\n\n/**\n * Validates whether the instance if of a certain type\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {ValidatorResult|null}\n */\nvalidators.type = function validateType (instance, schema, options, ctx) {\n  // Ignore undefined instances\n  if (instance === undefined) {\n    return null;\n  }\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var types = Array.isArray(schema.type) ? schema.type : [schema.type];\n  if (!types.some(this.testType.bind(this, instance, schema, options, ctx))) {\n    var list = types.map(function (v) {\n      if(!v) return;\n      var id = v.$id || v.id;\n      return id ? ('<' + id + '>') : (v+'');\n    });\n    result.addError({\n      name: 'type',\n      argument: list,\n      message: \"is not of a type(s) \" + list,\n    });\n  }\n  return result;\n};\n\nfunction testSchemaNoThrow(instance, options, ctx, callback, schema){\n  var throwError = options.throwError;\n  var throwAll = options.throwAll;\n  options.throwError = false;\n  options.throwAll = false;\n  var res = this.validateSchema(instance, schema, options, ctx);\n  options.throwError = throwError;\n  options.throwAll = throwAll;\n\n  if (!res.valid && callback instanceof Function) {\n    callback(res);\n  }\n  return res.valid;\n}\n\n/**\n * Validates whether the instance matches some of the given schemas\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {ValidatorResult|null}\n */\nvalidators.anyOf = function validateAnyOf (instance, schema, options, ctx) {\n  // Ignore undefined instances\n  if (instance === undefined) {\n    return null;\n  }\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var inner = new ValidatorResult(instance, schema, options, ctx);\n  if (!Array.isArray(schema.anyOf)){\n    throw new SchemaError(\"anyOf must be an array\");\n  }\n  if (!schema.anyOf.some(\n    testSchemaNoThrow.bind(\n      this, instance, options, ctx, function(res){inner.importErrors(res);}\n    ))) {\n    var list = schema.anyOf.map(function (v, i) {\n      var id = v.$id || v.id;\n      if(id) return '<' + id + '>';\n      return(v.title && JSON.stringify(v.title)) || (v['$ref'] && ('<' + v['$ref'] + '>')) || '[subschema '+i+']';\n    });\n    if (options.nestedErrors) {\n      result.importErrors(inner);\n    }\n    result.addError({\n      name: 'anyOf',\n      argument: list,\n      message: \"is not any of \" + list.join(','),\n    });\n  }\n  return result;\n};\n\n/**\n * Validates whether the instance matches every given schema\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {String|null}\n */\nvalidators.allOf = function validateAllOf (instance, schema, options, ctx) {\n  // Ignore undefined instances\n  if (instance === undefined) {\n    return null;\n  }\n  if (!Array.isArray(schema.allOf)){\n    throw new SchemaError(\"allOf must be an array\");\n  }\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var self = this;\n  schema.allOf.forEach(function(v, i){\n    var valid = self.validateSchema(instance, v, options, ctx);\n    if(!valid.valid){\n      var id = v.$id || v.id;\n      var msg = id || (v.title && JSON.stringify(v.title)) || (v['$ref'] && ('<' + v['$ref'] + '>')) || '[subschema '+i+']';\n      result.addError({\n        name: 'allOf',\n        argument: { id: msg, length: valid.errors.length, valid: valid },\n        message: 'does not match allOf schema ' + msg + ' with ' + valid.errors.length + ' error[s]:',\n      });\n      result.importErrors(valid);\n    }\n  });\n  return result;\n};\n\n/**\n * Validates whether the instance matches exactly one of the given schemas\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {String|null}\n */\nvalidators.oneOf = function validateOneOf (instance, schema, options, ctx) {\n  // Ignore undefined instances\n  if (instance === undefined) {\n    return null;\n  }\n  if (!Array.isArray(schema.oneOf)){\n    throw new SchemaError(\"oneOf must be an array\");\n  }\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var inner = new ValidatorResult(instance, schema, options, ctx);\n  var count = schema.oneOf.filter(\n    testSchemaNoThrow.bind(\n      this, instance, options, ctx, function(res) {inner.importErrors(res);}\n    ) ).length;\n  var list = schema.oneOf.map(function (v, i) {\n    var id = v.$id || v.id;\n    return id || (v.title && JSON.stringify(v.title)) || (v['$ref'] && ('<' + v['$ref'] + '>')) || '[subschema '+i+']';\n  });\n  if (count!==1) {\n    if (options.nestedErrors) {\n      result.importErrors(inner);\n    }\n    result.addError({\n      name: 'oneOf',\n      argument: list,\n      message: \"is not exactly one from \" + list.join(','),\n    });\n  }\n  return result;\n};\n\n/**\n * Validates \"then\" or \"else\" depending on the result of validating \"if\"\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {String|null}\n */\nvalidators.if = function validateIf (instance, schema, options, ctx) {\n  // Ignore undefined instances\n  if (instance === undefined) return null;\n  if (!helpers.isSchema(schema.if)) throw new Error('Expected \"if\" keyword to be a schema');\n  var ifValid = testSchemaNoThrow.call(this, instance, options, ctx, null, schema.if);\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var res;\n  if(ifValid){\n    if (schema.then === undefined) return;\n    if (!helpers.isSchema(schema.then)) throw new Error('Expected \"then\" keyword to be a schema');\n    res = this.validateSchema(instance, schema.then, options, ctx.makeChild(schema.then));\n    result.importErrors(res);\n  }else{\n    if (schema.else === undefined) return;\n    if (!helpers.isSchema(schema.else)) throw new Error('Expected \"else\" keyword to be a schema');\n    res = this.validateSchema(instance, schema.else, options, ctx.makeChild(schema.else));\n    result.importErrors(res);\n  }\n  return result;\n};\n\nfunction getEnumerableProperty(object, key){\n  // Determine if `key` shows up in `for(var key in object)`\n  // First test Object.hasOwnProperty.call as an optimization: that guarantees it does\n  if(Object.hasOwnProperty.call(object, key)) return object[key];\n  // Test `key in object` as an optimization; false means it won't\n  if(!(key in object)) return;\n  while( (object = Object.getPrototypeOf(object)) ){\n    if(Object.propertyIsEnumerable.call(object, key)) return object[key];\n  }\n}\n\n/**\n * Validates propertyNames\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {String|null|ValidatorResult}\n */\nvalidators.propertyNames = function validatePropertyNames (instance, schema, options, ctx) {\n  if(!this.types.object(instance)) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var subschema = schema.propertyNames!==undefined ? schema.propertyNames : {};\n  if(!helpers.isSchema(subschema)) throw new SchemaError('Expected \"propertyNames\" to be a schema (object or boolean)');\n\n  for (var property in instance) {\n    if(getEnumerableProperty(instance, property) !== undefined){\n      var res = this.validateSchema(property, subschema, options, ctx.makeChild(subschema));\n      result.importErrors(res);\n    }\n  }\n\n  return result;\n};\n\n/**\n * Validates properties\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {String|null|ValidatorResult}\n */\nvalidators.properties = function validateProperties (instance, schema, options, ctx) {\n  if(!this.types.object(instance)) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var properties = schema.properties || {};\n  for (var property in properties) {\n    var subschema = properties[property];\n    if(subschema===undefined){\n      continue;\n    }else if(subschema===null){\n      throw new SchemaError('Unexpected null, expected schema in \"properties\"');\n    }\n    if (typeof options.preValidateProperty == 'function') {\n      options.preValidateProperty(instance, property, subschema, options, ctx);\n    }\n    var prop = getEnumerableProperty(instance, property);\n    var res = this.validateSchema(prop, subschema, options, ctx.makeChild(subschema, property));\n    if(res.instance !== result.instance[property]) result.instance[property] = res.instance;\n    result.importErrors(res);\n  }\n  return result;\n};\n\n/**\n * Test a specific property within in instance against the additionalProperties schema attribute\n * This ignores properties with definitions in the properties schema attribute, but no other attributes.\n * If too many more types of property-existence tests pop up they may need their own class of tests (like `type` has)\n * @private\n * @return {boolean}\n */\nfunction testAdditionalProperty (instance, schema, options, ctx, property, result) {\n  if(!this.types.object(instance)) return;\n  if (schema.properties && schema.properties[property] !== undefined) {\n    return;\n  }\n  if (schema.additionalProperties === false) {\n    result.addError({\n      name: 'additionalProperties',\n      argument: property,\n      message: \"is not allowed to have the additional property \" + JSON.stringify(property),\n    });\n  } else {\n    var additionalProperties = schema.additionalProperties || {};\n\n    if (typeof options.preValidateProperty == 'function') {\n      options.preValidateProperty(instance, property, additionalProperties, options, ctx);\n    }\n\n    var res = this.validateSchema(instance[property], additionalProperties, options, ctx.makeChild(additionalProperties, property));\n    if(res.instance !== result.instance[property]) result.instance[property] = res.instance;\n    result.importErrors(res);\n  }\n}\n\n/**\n * Validates patternProperties\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {String|null|ValidatorResult}\n */\nvalidators.patternProperties = function validatePatternProperties (instance, schema, options, ctx) {\n  if(!this.types.object(instance)) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var patternProperties = schema.patternProperties || {};\n\n  for (var property in instance) {\n    var test = true;\n    for (var pattern in patternProperties) {\n      var subschema = patternProperties[pattern];\n      if(subschema===undefined){\n        continue;\n      }else if(subschema===null){\n        throw new SchemaError('Unexpected null, expected schema in \"patternProperties\"');\n      }\n      try {\n        var regexp = new RegExp(pattern, 'u');\n      } catch(_e) {\n        // In the event the stricter handling causes an error, fall back on the forgiving handling\n        // DEPRECATED\n        regexp = new RegExp(pattern);\n      }\n      if (!regexp.test(property)) {\n        continue;\n      }\n      test = false;\n\n      if (typeof options.preValidateProperty == 'function') {\n        options.preValidateProperty(instance, property, subschema, options, ctx);\n      }\n\n      var res = this.validateSchema(instance[property], subschema, options, ctx.makeChild(subschema, property));\n      if(res.instance !== result.instance[property]) result.instance[property] = res.instance;\n      result.importErrors(res);\n    }\n    if (test) {\n      testAdditionalProperty.call(this, instance, schema, options, ctx, property, result);\n    }\n  }\n\n  return result;\n};\n\n/**\n * Validates additionalProperties\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {String|null|ValidatorResult}\n */\nvalidators.additionalProperties = function validateAdditionalProperties (instance, schema, options, ctx) {\n  if(!this.types.object(instance)) return;\n  // if patternProperties is defined then we'll test when that one is called instead\n  if (schema.patternProperties) {\n    return null;\n  }\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  for (var property in instance) {\n    testAdditionalProperty.call(this, instance, schema, options, ctx, property, result);\n  }\n  return result;\n};\n\n/**\n * Validates whether the instance value is at least of a certain length, when the instance value is a string.\n * @param instance\n * @param schema\n * @return {String|null}\n */\nvalidators.minProperties = function validateMinProperties (instance, schema, options, ctx) {\n  if (!this.types.object(instance)) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var keys = Object.keys(instance);\n  if (!(keys.length >= schema.minProperties)) {\n    result.addError({\n      name: 'minProperties',\n      argument: schema.minProperties,\n      message: \"does not meet minimum property length of \" + schema.minProperties,\n    });\n  }\n  return result;\n};\n\n/**\n * Validates whether the instance value is at most of a certain length, when the instance value is a string.\n * @param instance\n * @param schema\n * @return {String|null}\n */\nvalidators.maxProperties = function validateMaxProperties (instance, schema, options, ctx) {\n  if (!this.types.object(instance)) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var keys = Object.keys(instance);\n  if (!(keys.length <= schema.maxProperties)) {\n    result.addError({\n      name: 'maxProperties',\n      argument: schema.maxProperties,\n      message: \"does not meet maximum property length of \" + schema.maxProperties,\n    });\n  }\n  return result;\n};\n\n/**\n * Validates items when instance is an array\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {String|null|ValidatorResult}\n */\nvalidators.items = function validateItems (instance, schema, options, ctx) {\n  var self = this;\n  if (!this.types.array(instance)) return;\n  if (!schema.items) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  instance.every(function (value, i) {\n    var items = Array.isArray(schema.items) ? (schema.items[i] || schema.additionalItems) : schema.items;\n    if (items === undefined) {\n      return true;\n    }\n    if (items === false) {\n      result.addError({\n        name: 'items',\n        message: \"additionalItems not permitted\",\n      });\n      return false;\n    }\n    var res = self.validateSchema(value, items, options, ctx.makeChild(items, i));\n    if(res.instance !== result.instance[i]) result.instance[i] = res.instance;\n    result.importErrors(res);\n    return true;\n  });\n  return result;\n};\n\n/**\n * Validates minimum and exclusiveMinimum when the type of the instance value is a number.\n * @param instance\n * @param schema\n * @return {String|null}\n */\nvalidators.minimum = function validateMinimum (instance, schema, options, ctx) {\n  if (!this.types.number(instance)) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  if (schema.exclusiveMinimum && schema.exclusiveMinimum === true) {\n    if(!(instance > schema.minimum)){\n      result.addError({\n        name: 'minimum',\n        argument: schema.minimum,\n        message: \"must be greater than \" + schema.minimum,\n      });\n    }\n  } else {\n    if(!(instance >= schema.minimum)){\n      result.addError({\n        name: 'minimum',\n        argument: schema.minimum,\n        message: \"must be greater than or equal to \" + schema.minimum,\n      });\n    }\n  }\n  return result;\n};\n\n/**\n * Validates maximum and exclusiveMaximum when the type of the instance value is a number.\n * @param instance\n * @param schema\n * @return {String|null}\n */\nvalidators.maximum = function validateMaximum (instance, schema, options, ctx) {\n  if (!this.types.number(instance)) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  if (schema.exclusiveMaximum && schema.exclusiveMaximum === true) {\n    if(!(instance < schema.maximum)){\n      result.addError({\n        name: 'maximum',\n        argument: schema.maximum,\n        message: \"must be less than \" + schema.maximum,\n      });\n    }\n  } else {\n    if(!(instance <= schema.maximum)){\n      result.addError({\n        name: 'maximum',\n        argument: schema.maximum,\n        message: \"must be less than or equal to \" + schema.maximum,\n      });\n    }\n  }\n  return result;\n};\n\n/**\n * Validates the number form of exclusiveMinimum when the type of the instance value is a number.\n * @param instance\n * @param schema\n * @return {String|null}\n */\nvalidators.exclusiveMinimum = function validateExclusiveMinimum (instance, schema, options, ctx) {\n  // Support the boolean form of exclusiveMinimum, which is handled by the \"minimum\" keyword.\n  if(typeof schema.exclusiveMaximum === 'boolean') return;\n  if (!this.types.number(instance)) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var valid = instance > schema.exclusiveMinimum;\n  if (!valid) {\n    result.addError({\n      name: 'exclusiveMinimum',\n      argument: schema.exclusiveMinimum,\n      message: \"must be strictly greater than \" + schema.exclusiveMinimum,\n    });\n  }\n  return result;\n};\n\n/**\n * Validates the number form of exclusiveMaximum when the type of the instance value is a number.\n * @param instance\n * @param schema\n * @return {String|null}\n */\nvalidators.exclusiveMaximum = function validateExclusiveMaximum (instance, schema, options, ctx) {\n  // Support the boolean form of exclusiveMaximum, which is handled by the \"maximum\" keyword.\n  if(typeof schema.exclusiveMaximum === 'boolean') return;\n  if (!this.types.number(instance)) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var valid = instance < schema.exclusiveMaximum;\n  if (!valid) {\n    result.addError({\n      name: 'exclusiveMaximum',\n      argument: schema.exclusiveMaximum,\n      message: \"must be strictly less than \" + schema.exclusiveMaximum,\n    });\n  }\n  return result;\n};\n\n/**\n * Perform validation for multipleOf and divisibleBy, which are essentially the same.\n * @param instance\n * @param schema\n * @param validationType\n * @param errorMessage\n * @returns {String|null}\n */\nvar validateMultipleOfOrDivisbleBy = function validateMultipleOfOrDivisbleBy (instance, schema, options, ctx, validationType, errorMessage) {\n  if (!this.types.number(instance)) return;\n\n  var validationArgument = schema[validationType];\n  if (validationArgument == 0) {\n    throw new SchemaError(validationType + \" cannot be zero\");\n  }\n\n  var result = new ValidatorResult(instance, schema, options, ctx);\n\n  var instanceDecimals = helpers.getDecimalPlaces(instance);\n  var divisorDecimals = helpers.getDecimalPlaces(validationArgument);\n\n  var maxDecimals = Math.max(instanceDecimals , divisorDecimals);\n  var multiplier = Math.pow(10, maxDecimals);\n\n  if (Math.round(instance * multiplier) % Math.round(validationArgument * multiplier) !== 0) {\n    result.addError({\n      name: validationType,\n      argument:  validationArgument,\n      message: errorMessage + JSON.stringify(validationArgument),\n    });\n  }\n\n  return result;\n};\n\n/**\n * Validates divisibleBy when the type of the instance value is a number.\n * @param instance\n * @param schema\n * @return {String|null}\n */\nvalidators.multipleOf = function validateMultipleOf (instance, schema, options, ctx) {\n  return validateMultipleOfOrDivisbleBy.call(this, instance, schema, options, ctx, \"multipleOf\", \"is not a multiple of (divisible by) \");\n};\n\n/**\n * Validates multipleOf when the type of the instance value is a number.\n * @param instance\n * @param schema\n * @return {String|null}\n */\nvalidators.divisibleBy = function validateDivisibleBy (instance, schema, options, ctx) {\n  return validateMultipleOfOrDivisbleBy.call(this, instance, schema, options, ctx, \"divisibleBy\", \"is not divisible by (multiple of) \");\n};\n\n/**\n * Validates whether the instance value is present.\n * @param instance\n * @param schema\n * @return {String|null}\n */\nvalidators.required = function validateRequired (instance, schema, options, ctx) {\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  if (instance === undefined && schema.required === true) {\n    // A boolean form is implemented for reverse-compatibility with schemas written against older drafts\n    result.addError({\n      name: 'required',\n      message: \"is required\",\n    });\n  } else if (this.types.object(instance) && Array.isArray(schema.required)) {\n    schema.required.forEach(function(n){\n      if(getEnumerableProperty(instance, n)===undefined){\n        result.addError({\n          name: 'required',\n          argument: n,\n          message: \"requires property \" + JSON.stringify(n),\n        });\n      }\n    });\n  }\n  return result;\n};\n\n/**\n * Validates whether the instance value matches the regular expression, when the instance value is a string.\n * @param instance\n * @param schema\n * @return {String|null}\n */\nvalidators.pattern = function validatePattern (instance, schema, options, ctx) {\n  if (!this.types.string(instance)) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var pattern = schema.pattern;\n  try {\n    var regexp = new RegExp(pattern, 'u');\n  } catch(_e) {\n    // In the event the stricter handling causes an error, fall back on the forgiving handling\n    // DEPRECATED\n    regexp = new RegExp(pattern);\n  }\n  if (!instance.match(regexp)) {\n    result.addError({\n      name: 'pattern',\n      argument: schema.pattern,\n      message: \"does not match pattern \" + JSON.stringify(schema.pattern.toString()),\n    });\n  }\n  return result;\n};\n\n/**\n * Validates whether the instance value is of a certain defined format or a custom\n * format.\n * The following formats are supported for string types:\n *   - date-time\n *   - date\n *   - time\n *   - ip-address\n *   - ipv6\n *   - uri\n *   - color\n *   - host-name\n *   - alpha\n *   - alpha-numeric\n *   - utc-millisec\n * @param instance\n * @param schema\n * @param [options]\n * @param [ctx]\n * @return {String|null}\n */\nvalidators.format = function validateFormat (instance, schema, options, ctx) {\n  if (instance===undefined) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  if (!result.disableFormat && !helpers.isFormat(instance, schema.format, this)) {\n    result.addError({\n      name: 'format',\n      argument: schema.format,\n      message: \"does not conform to the \" + JSON.stringify(schema.format) + \" format\",\n    });\n  }\n  return result;\n};\n\n/**\n * Validates whether the instance value is at least of a certain length, when the instance value is a string.\n * @param instance\n * @param schema\n * @return {String|null}\n */\nvalidators.minLength = function validateMinLength (instance, schema, options, ctx) {\n  if (!this.types.string(instance)) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var hsp = instance.match(/[\\uDC00-\\uDFFF]/g);\n  var length = instance.length - (hsp ? hsp.length : 0);\n  if (!(length >= schema.minLength)) {\n    result.addError({\n      name: 'minLength',\n      argument: schema.minLength,\n      message: \"does not meet minimum length of \" + schema.minLength,\n    });\n  }\n  return result;\n};\n\n/**\n * Validates whether the instance value is at most of a certain length, when the instance value is a string.\n * @param instance\n * @param schema\n * @return {String|null}\n */\nvalidators.maxLength = function validateMaxLength (instance, schema, options, ctx) {\n  if (!this.types.string(instance)) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  // TODO if this was already computed in \"minLength\", use that value instead of re-computing\n  var hsp = instance.match(/[\\uDC00-\\uDFFF]/g);\n  var length = instance.length - (hsp ? hsp.length : 0);\n  if (!(length <= schema.maxLength)) {\n    result.addError({\n      name: 'maxLength',\n      argument: schema.maxLength,\n      message: \"does not meet maximum length of \" + schema.maxLength,\n    });\n  }\n  return result;\n};\n\n/**\n * Validates whether instance contains at least a minimum number of items, when the instance is an Array.\n * @param instance\n * @param schema\n * @return {String|null}\n */\nvalidators.minItems = function validateMinItems (instance, schema, options, ctx) {\n  if (!this.types.array(instance)) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  if (!(instance.length >= schema.minItems)) {\n    result.addError({\n      name: 'minItems',\n      argument: schema.minItems,\n      message: \"does not meet minimum length of \" + schema.minItems,\n    });\n  }\n  return result;\n};\n\n/**\n * Validates whether instance contains no more than a maximum number of items, when the instance is an Array.\n * @param instance\n * @param schema\n * @return {String|null}\n */\nvalidators.maxItems = function validateMaxItems (instance, schema, options, ctx) {\n  if (!this.types.array(instance)) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  if (!(instance.length <= schema.maxItems)) {\n    result.addError({\n      name: 'maxItems',\n      argument: schema.maxItems,\n      message: \"does not meet maximum length of \" + schema.maxItems,\n    });\n  }\n  return result;\n};\n\n/**\n * Deep compares arrays for duplicates\n * @param v\n * @param i\n * @param a\n * @private\n * @return {boolean}\n */\nfunction testArrays (v, i, a) {\n  var j, len = a.length;\n  for (j = i + 1, len; j < len; j++) {\n    if (helpers.deepCompareStrict(v, a[j])) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Validates whether there are no duplicates, when the instance is an Array.\n * @param instance\n * @return {String|null}\n */\nvalidators.uniqueItems = function validateUniqueItems (instance, schema, options, ctx) {\n  if (schema.uniqueItems!==true) return;\n  if (!this.types.array(instance)) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  if (!instance.every(testArrays)) {\n    result.addError({\n      name: 'uniqueItems',\n      message: \"contains duplicate item\",\n    });\n  }\n  return result;\n};\n\n/**\n * Validate for the presence of dependency properties, if the instance is an object.\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {null|ValidatorResult}\n */\nvalidators.dependencies = function validateDependencies (instance, schema, options, ctx) {\n  if (!this.types.object(instance)) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  for (var property in schema.dependencies) {\n    if (instance[property] === undefined) {\n      continue;\n    }\n    var dep = schema.dependencies[property];\n    var childContext = ctx.makeChild(dep, property);\n    if (typeof dep == 'string') {\n      dep = [dep];\n    }\n    if (Array.isArray(dep)) {\n      dep.forEach(function (prop) {\n        if (instance[prop] === undefined) {\n          result.addError({\n            // FIXME there's two different \"dependencies\" errors here with slightly different outputs\n            // Can we make these the same? Or should we create different error types?\n            name: 'dependencies',\n            argument: childContext.propertyPath,\n            message: \"property \" + prop + \" not found, required by \" + childContext.propertyPath,\n          });\n        }\n      });\n    } else {\n      var res = this.validateSchema(instance, dep, options, childContext);\n      if(result.instance !== res.instance) result.instance = res.instance;\n      if (res && res.errors.length) {\n        result.addError({\n          name: 'dependencies',\n          argument: childContext.propertyPath,\n          message: \"does not meet dependency required by \" + childContext.propertyPath,\n        });\n        result.importErrors(res);\n      }\n    }\n  }\n  return result;\n};\n\n/**\n * Validates whether the instance value is one of the enumerated values.\n *\n * @param instance\n * @param schema\n * @return {ValidatorResult|null}\n */\nvalidators['enum'] = function validateEnum (instance, schema, options, ctx) {\n  if (instance === undefined) {\n    return null;\n  }\n  if (!Array.isArray(schema['enum'])) {\n    throw new SchemaError(\"enum expects an array\", schema);\n  }\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  if (!schema['enum'].some(helpers.deepCompareStrict.bind(null, instance))) {\n    result.addError({\n      name: 'enum',\n      argument: schema['enum'],\n      message: \"is not one of enum values: \" + schema['enum'].map(String).join(','),\n    });\n  }\n  return result;\n};\n\n/**\n * Validates whether the instance exactly matches a given value\n *\n * @param instance\n * @param schema\n * @return {ValidatorResult|null}\n */\nvalidators['const'] = function validateEnum (instance, schema, options, ctx) {\n  if (instance === undefined) {\n    return null;\n  }\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  if (!helpers.deepCompareStrict(schema['const'], instance)) {\n    result.addError({\n      name: 'const',\n      argument: schema['const'],\n      message: \"does not exactly match expected constant: \" + schema['const'],\n    });\n  }\n  return result;\n};\n\n/**\n * Validates whether the instance if of a prohibited type.\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {null|ValidatorResult}\n */\nvalidators.not = validators.disallow = function validateNot (instance, schema, options, ctx) {\n  var self = this;\n  if(instance===undefined) return null;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var notTypes = schema.not || schema.disallow;\n  if(!notTypes) return null;\n  if(!Array.isArray(notTypes)) notTypes=[notTypes];\n  notTypes.forEach(function (type) {\n    if (self.testType(instance, schema, options, ctx, type)) {\n      var id = type && (type.$id || type.id);\n      var schemaId = id || type;\n      result.addError({\n        name: 'not',\n        argument: schemaId,\n        message: \"is of prohibited type \" + schemaId,\n      });\n    }\n  });\n  return result;\n};\n\nmodule.exports = attribute;\n"]},"metadata":{},"sourceType":"script"}