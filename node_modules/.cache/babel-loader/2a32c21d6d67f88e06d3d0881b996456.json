{"ast":null,"code":"import { useCallback, useMemo } from 'react';\nimport { useDispatch, useSelector } from 'react-redux';\nimport { useWallet } from 'use-wallet';\nimport { addTransaction, clearAllTransactions } from './actions';\n// helper that can take a ethers library transaction response and add it to the list of transactions\nexport function useTransactionAdder() {\n  const {\n    chainId,\n    account\n  } = useWallet();\n  const dispatch = useDispatch();\n  return useCallback(function (response) {\n    let {\n      summary,\n      approval\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    if (!account) return;\n    if (!chainId) return;\n    const {\n      hash\n    } = response;\n\n    if (!hash) {\n      throw Error('No transaction hash found.');\n    }\n\n    dispatch(addTransaction({\n      hash,\n      from: account,\n      chainId,\n      approval,\n      summary\n    }));\n  }, [dispatch, chainId, account]);\n} // returns all the transactions for the current chain\n\nexport function useAllTransactions() {\n  var _state$chainId;\n\n  const {\n    chainId\n  } = useWallet();\n  const state = useSelector(state => state.transactions);\n  return chainId ? (_state$chainId = state[chainId]) !== null && _state$chainId !== void 0 ? _state$chainId : {} : {};\n}\nexport function useIsTransactionPending(transactionHash) {\n  const transactions = useAllTransactions();\n\n  if (!transactionHash || !transactions[transactionHash]) {\n    return false;\n  }\n\n  return !transactions[transactionHash].receipt;\n}\n/**\n * Returns whether a transaction happened in the last day (86400 seconds * 1000 milliseconds / second)\n * @param tx to check for recency\n */\n\nexport function isTransactionRecent(tx) {\n  return new Date().getTime() - tx.addedTime < 86400000;\n} // returns whether a token has a pending approval transaction\n\nexport function useHasPendingApproval(tokenAddress, spender) {\n  const allTransactions = useAllTransactions();\n  return useMemo(() => typeof tokenAddress === 'string' && typeof spender === 'string' && Object.keys(allTransactions).some(hash => {\n    const tx = allTransactions[hash];\n    if (!tx) return false;\n\n    if (tx.receipt) {\n      return false;\n    } else {\n      const approval = tx.approval;\n      if (!approval) return false;\n      return approval.spender === spender && approval.tokenAddress === tokenAddress && isTransactionRecent(tx);\n    }\n  }), [allTransactions, spender, tokenAddress]);\n}\nexport function useClearAllTransactions() {\n  const {\n    chainId\n  } = useWallet();\n  const dispatch = useDispatch();\n  return {\n    clearAllTransactions: useCallback(() => dispatch(clearAllTransactions({\n      chainId\n    })), [dispatch, chainId])\n  };\n}","map":{"version":3,"sources":["/home/shashwat/Projects/Intern/src/state/transactions/hooks.tsx"],"names":["useCallback","useMemo","useDispatch","useSelector","useWallet","addTransaction","clearAllTransactions","useTransactionAdder","chainId","account","dispatch","response","summary","approval","hash","Error","from","useAllTransactions","state","transactions","useIsTransactionPending","transactionHash","receipt","isTransactionRecent","tx","Date","getTime","addedTime","useHasPendingApproval","tokenAddress","spender","allTransactions","Object","keys","some","useClearAllTransactions"],"mappings":"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","sourcesContent":["import {TransactionResponse} from '@ethersproject/providers';\nimport {useCallback, useMemo} from 'react';\nimport {useDispatch, useSelector} from 'react-redux';\nimport {useWallet} from 'use-wallet';\n\nimport {AppDispatch, AppState} from '../index';\nimport {addTransaction, clearAllTransactions} from './actions';\nimport {TransactionDetails} from './reducer';\n\n// helper that can take a ethers library transaction response and add it to the list of transactions\nexport function useTransactionAdder(): (\n  response: TransactionResponse,\n  customData?: {summary?: string; approval?: {tokenAddress: string; spender: string}},\n) => void {\n  const {chainId, account} = useWallet();\n  const dispatch = useDispatch<AppDispatch>();\n\n  return useCallback(\n    (\n      response: TransactionResponse,\n      {summary, approval}: {summary?: string; approval?: {tokenAddress: string; spender: string}} = {},\n    ) => {\n      if (!account) return;\n      if (!chainId) return;\n\n      const {hash} = response;\n      if (!hash) {\n        throw Error('No transaction hash found.');\n      }\n      dispatch(addTransaction({hash, from: account, chainId, approval, summary}));\n    },\n    [dispatch, chainId, account],\n  );\n}\n\n// returns all the transactions for the current chain\nexport function useAllTransactions(): {[txHash: string]: TransactionDetails} {\n  const {chainId} = useWallet();\n  const state = useSelector<AppState, AppState['transactions']>((state) => state.transactions);\n\n  return chainId ? state[chainId] ?? {} : {};\n}\n\nexport function useIsTransactionPending(transactionHash?: string): boolean {\n  const transactions = useAllTransactions();\n  if (!transactionHash || !transactions[transactionHash]) {\n    return false;\n  }\n  return !transactions[transactionHash].receipt;\n}\n\n/**\n * Returns whether a transaction happened in the last day (86400 seconds * 1000 milliseconds / second)\n * @param tx to check for recency\n */\nexport function isTransactionRecent(tx: TransactionDetails): boolean {\n  return new Date().getTime() - tx.addedTime < 86_400_000;\n}\n\n// returns whether a token has a pending approval transaction\nexport function useHasPendingApproval(tokenAddress: string | undefined, spender: string | undefined): boolean {\n  const allTransactions = useAllTransactions();\n  return useMemo(\n    () =>\n      typeof tokenAddress === 'string' &&\n      typeof spender === 'string' &&\n      Object.keys(allTransactions).some((hash) => {\n        const tx = allTransactions[hash];\n        if (!tx) return false;\n        if (tx.receipt) {\n          return false;\n        } else {\n          const approval = tx.approval;\n          if (!approval) return false;\n          return approval.spender === spender && approval.tokenAddress === tokenAddress && isTransactionRecent(tx);\n        }\n      }),\n    [allTransactions, spender, tokenAddress],\n  );\n}\n\nexport function useClearAllTransactions(): {clearAllTransactions: () => void} {\n  const {chainId} = useWallet();\n  const dispatch = useDispatch<AppDispatch>();\n  return {\n    clearAllTransactions: useCallback(() => dispatch(clearAllTransactions({chainId})), [dispatch, chainId]),\n  };\n}\n"]},"metadata":{},"sourceType":"module"}