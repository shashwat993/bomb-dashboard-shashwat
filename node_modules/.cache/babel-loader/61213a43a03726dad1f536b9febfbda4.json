{"ast":null,"code":"const EventEmitter = require('events');\n\nconst parse = require('../parse');\n\nconst dev = process.env.NODE_ENV === 'development';\nlet WebSocket;\n\nclass WebSocketConnection extends EventEmitter {\n  constructor(_WebSocket, url, options) {\n    super();\n    WebSocket = _WebSocket;\n    setTimeout(() => this.create(url, options), 0);\n  }\n\n  create(url, options) {\n    if (!WebSocket) this.emit('error', new Error('No WebSocket transport available'));\n\n    try {\n      this.socket = new WebSocket(url);\n    } catch (e) {\n      return this.emit('error', e);\n    }\n\n    this.socket.addEventListener('error', err => this.emit('error', err));\n    this.socket.addEventListener('open', () => {\n      this.emit('connect');\n      this.socket.addEventListener('message', message => {\n        const data = typeof message.data === 'string' ? message.data : '';\n        parse(data, (err, payloads) => {\n          if (err) return; //\n\n          payloads.forEach(load => {\n            if (Array.isArray(load)) {\n              load.forEach(payload => this.emit('payload', payload));\n            } else {\n              this.emit('payload', load);\n            }\n          });\n        });\n      });\n      this.socket.addEventListener('close', () => this.onClose());\n    });\n  }\n\n  onClose() {\n    this.socket = null;\n    this.closed = true;\n    if (dev) console.log('Closing WebSocket connection');\n    this.emit('close');\n    this.removeAllListeners();\n  }\n\n  close() {\n    if (this.socket) {\n      this.socket.close();\n    } else {\n      this.onClose();\n    }\n  }\n\n  error(payload, message) {\n    let code = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;\n    this.emit('payload', {\n      id: payload.id,\n      jsonrpc: payload.jsonrpc,\n      error: {\n        message,\n        code\n      }\n    });\n  }\n\n  send(payload) {\n    if (this.socket && this.socket.readyState === this.socket.CONNECTING) {\n      setTimeout(_ => this.send(payload), 10);\n    } else if (!this.socket || this.socket.readyState > 1) {\n      this.connected = false;\n      this.error(payload, 'Not connected');\n    } else {\n      this.socket.send(JSON.stringify(payload));\n    }\n  }\n\n}\n\nmodule.exports = WebSocket => (url, cb) => new WebSocketConnection(WebSocket, url, cb);","map":{"version":3,"sources":["/home/shashwat/Projects/Dyeus/node_modules/eth-provider/connections/ws.js"],"names":["EventEmitter","require","parse","dev","process","env","NODE_ENV","WebSocket","WebSocketConnection","constructor","_WebSocket","url","options","setTimeout","create","emit","Error","socket","e","addEventListener","err","message","data","payloads","forEach","load","Array","isArray","payload","onClose","closed","console","log","removeAllListeners","close","error","code","id","jsonrpc","send","readyState","CONNECTING","_","connected","JSON","stringify","module","exports","cb"],"mappings":"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","sourcesContent":["const EventEmitter = require('events')\nconst parse = require('../parse')\nconst dev = process.env.NODE_ENV === 'development'\n\nlet WebSocket\n\nclass WebSocketConnection extends EventEmitter {\n  constructor (_WebSocket, url, options) {\n    super()\n    WebSocket = _WebSocket\n    setTimeout(() => this.create(url, options), 0)\n  }\n\n  create (url, options) {\n    if (!WebSocket) this.emit('error', new Error('No WebSocket transport available'))\n    try { this.socket = new WebSocket(url) } catch (e) { return this.emit('error', e) }\n    this.socket.addEventListener('error', err => this.emit('error', err))\n    this.socket.addEventListener('open', () => {\n      this.emit('connect')\n      this.socket.addEventListener('message', message => {\n        const data = typeof message.data === 'string' ? message.data : ''\n        parse(data, (err, payloads) => {\n          if (err) return //\n          payloads.forEach(load => {\n            if (Array.isArray(load)) {\n              load.forEach(payload => this.emit('payload', payload))\n            } else {\n              this.emit('payload', load)\n            }\n          })\n        })\n      })\n      this.socket.addEventListener('close', () => this.onClose())\n    })\n  }\n\n  onClose () {\n    this.socket = null\n    this.closed = true\n    if (dev) console.log('Closing WebSocket connection')\n    this.emit('close')\n    this.removeAllListeners()\n  }\n\n  close () {\n    if (this.socket) {\n      this.socket.close()\n    } else {\n      this.onClose()\n    }\n  }\n\n  error (payload, message, code = -1) {\n    this.emit('payload', { id: payload.id, jsonrpc: payload.jsonrpc, error: { message, code } })\n  }\n\n  send (payload) {\n    if (this.socket && this.socket.readyState === this.socket.CONNECTING) {\n      setTimeout(_ => this.send(payload), 10)\n    } else if (!this.socket || this.socket.readyState > 1) {\n      this.connected = false\n      this.error(payload, 'Not connected')\n    } else {\n      this.socket.send(JSON.stringify(payload))\n    }\n  }\n}\n\nmodule.exports = WebSocket => (url, cb) => new WebSocketConnection(WebSocket, url, cb)\n"]},"metadata":{},"sourceType":"script"}