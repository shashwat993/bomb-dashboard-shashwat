{"ast":null,"code":"import { EventEmitter } from \"events\";\nimport fetch from \"cross-fetch\";\nimport { safeJsonParse, safeJsonStringify } from \"@walletconnect/safe-json\";\nimport { formatJsonRpcError, isHttpUrl, parseConnectionError } from \"@walletconnect/jsonrpc-utils\";\nconst DEFAULT_HTTP_HEADERS = {\n  Accept: \"application/json\",\n  \"Content-Type\": \"application/json\"\n};\nconst DEFAULT_HTTP_METHOD = \"POST\";\nconst DEFAULT_FETCH_OPTS = {\n  headers: DEFAULT_HTTP_HEADERS,\n  method: DEFAULT_HTTP_METHOD\n};\nexport class HttpConnection {\n  constructor(url) {\n    this.url = url;\n    this.events = new EventEmitter();\n    this.isAvailable = false;\n    this.registering = false;\n\n    if (!isHttpUrl(url)) {\n      throw new Error(`Provided URL is not compatible with HTTP connection: ${url}`);\n    }\n\n    this.url = url;\n  }\n\n  get connected() {\n    return this.isAvailable;\n  }\n\n  get connecting() {\n    return this.registering;\n  }\n\n  on(event, listener) {\n    this.events.on(event, listener);\n  }\n\n  once(event, listener) {\n    this.events.once(event, listener);\n  }\n\n  off(event, listener) {\n    this.events.off(event, listener);\n  }\n\n  removeListener(event, listener) {\n    this.events.removeListener(event, listener);\n  }\n\n  async open() {\n    let url = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.url;\n    await this.register(url);\n  }\n\n  async close() {\n    if (!this.isAvailable) {\n      throw new Error(\"Connection already closed\");\n    }\n\n    this.onClose();\n  }\n\n  async send(payload, context) {\n    if (!this.isAvailable) {\n      await this.register();\n    }\n\n    try {\n      const body = safeJsonStringify(payload);\n      const res = await fetch(this.url, Object.assign(Object.assign({}, DEFAULT_FETCH_OPTS), {\n        body\n      }));\n      const data = await res.json();\n      this.onPayload({\n        data\n      });\n    } catch (e) {\n      this.onError(payload.id, e);\n    }\n  }\n\n  async register() {\n    let url = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.url;\n\n    if (!isHttpUrl(url)) {\n      throw new Error(`Provided URL is not compatible with HTTP connection: ${url}`);\n    }\n\n    if (this.registering) {\n      return new Promise((resolve, reject) => {\n        this.events.once(\"register_error\", error => {\n          reject(error);\n        });\n        this.events.once(\"open\", () => {\n          if (typeof this.isAvailable === \"undefined\") {\n            return reject(new Error(\"HTTP connection is missing or invalid\"));\n          }\n\n          resolve();\n        });\n      });\n    }\n\n    this.url = url;\n    this.registering = true;\n\n    try {\n      const body = safeJsonStringify({\n        id: 1,\n        jsonrpc: \"2.0\",\n        method: \"test\",\n        params: []\n      });\n      await fetch(url, Object.assign(Object.assign({}, DEFAULT_FETCH_OPTS), {\n        body\n      }));\n      this.onOpen();\n    } catch (e) {\n      const error = this.parseError(e);\n      this.events.emit(\"register_error\", error);\n      this.onClose();\n      throw error;\n    }\n  }\n\n  onOpen() {\n    this.isAvailable = true;\n    this.registering = false;\n    this.events.emit(\"open\");\n  }\n\n  onClose() {\n    this.isAvailable = false;\n    this.registering = false;\n    this.events.emit(\"close\");\n  }\n\n  onPayload(e) {\n    if (typeof e.data === \"undefined\") return;\n    const payload = typeof e.data === \"string\" ? safeJsonParse(e.data) : e.data;\n    this.events.emit(\"payload\", payload);\n  }\n\n  onError(id, e) {\n    const error = this.parseError(e);\n    const message = error.message || error.toString();\n    const payload = formatJsonRpcError(id, message);\n    this.events.emit(\"payload\", payload);\n  }\n\n  parseError(e) {\n    let url = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.url;\n    return parseConnectionError(e, url, \"HTTP\");\n  }\n\n}\nexport default HttpConnection;","map":{"version":3,"sources":["../../src/http.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { EventEmitter } from \"events\";\nimport fetch from \"cross-fetch\";\nimport { safeJsonParse, safeJsonStringify } from \"@walletconnect/safe-json\";\nimport { formatJsonRpcError, isHttpUrl, parseConnectionError, } from \"@walletconnect/jsonrpc-utils\";\nconst DEFAULT_HTTP_HEADERS = {\n    Accept: \"application/json\",\n    \"Content-Type\": \"application/json\",\n};\nconst DEFAULT_HTTP_METHOD = \"POST\";\nconst DEFAULT_FETCH_OPTS = {\n    headers: DEFAULT_HTTP_HEADERS,\n    method: DEFAULT_HTTP_METHOD,\n};\nexport class HttpConnection {\n    constructor(url) {\n        this.url = url;\n        this.events = new EventEmitter();\n        this.isAvailable = false;\n        this.registering = false;\n        if (!isHttpUrl(url)) {\n            throw new Error(`Provided URL is not compatible with HTTP connection: ${url}`);\n        }\n        this.url = url;\n    }\n    get connected() {\n        return this.isAvailable;\n    }\n    get connecting() {\n        return this.registering;\n    }\n    on(event, listener) {\n        this.events.on(event, listener);\n    }\n    once(event, listener) {\n        this.events.once(event, listener);\n    }\n    off(event, listener) {\n        this.events.off(event, listener);\n    }\n    removeListener(event, listener) {\n        this.events.removeListener(event, listener);\n    }\n    async open(url = this.url) {\n        await this.register(url);\n    }\n    async close() {\n        if (!this.isAvailable) {\n            throw new Error(\"Connection already closed\");\n        }\n        this.onClose();\n    }\n    async send(payload, context) {\n        if (!this.isAvailable) {\n            await this.register();\n        }\n        try {\n            const body = safeJsonStringify(payload);\n            const res = await fetch(this.url, Object.assign(Object.assign({}, DEFAULT_FETCH_OPTS), { body }));\n            const data = await res.json();\n            this.onPayload({ data });\n        }\n        catch (e) {\n            this.onError(payload.id, e);\n        }\n    }\n    async register(url = this.url) {\n        if (!isHttpUrl(url)) {\n            throw new Error(`Provided URL is not compatible with HTTP connection: ${url}`);\n        }\n        if (this.registering) {\n            return new Promise((resolve, reject) => {\n                this.events.once(\"register_error\", error => {\n                    reject(error);\n                });\n                this.events.once(\"open\", () => {\n                    if (typeof this.isAvailable === \"undefined\") {\n                        return reject(new Error(\"HTTP connection is missing or invalid\"));\n                    }\n                    resolve();\n                });\n            });\n        }\n        this.url = url;\n        this.registering = true;\n        try {\n            const body = safeJsonStringify({ id: 1, jsonrpc: \"2.0\", method: \"test\", params: [] });\n            await fetch(url, Object.assign(Object.assign({}, DEFAULT_FETCH_OPTS), { body }));\n            this.onOpen();\n        }\n        catch (e) {\n            const error = this.parseError(e);\n            this.events.emit(\"register_error\", error);\n            this.onClose();\n            throw error;\n        }\n    }\n    onOpen() {\n        this.isAvailable = true;\n        this.registering = false;\n        this.events.emit(\"open\");\n    }\n    onClose() {\n        this.isAvailable = false;\n        this.registering = false;\n        this.events.emit(\"close\");\n    }\n    onPayload(e) {\n        if (typeof e.data === \"undefined\")\n            return;\n        const payload = typeof e.data === \"string\" ? safeJsonParse(e.data) : e.data;\n        this.events.emit(\"payload\", payload);\n    }\n    onError(id, e) {\n        const error = this.parseError(e);\n        const message = error.message || error.toString();\n        const payload = formatJsonRpcError(id, message);\n        this.events.emit(\"payload\", payload);\n    }\n    parseError(e, url = this.url) {\n        return parseConnectionError(e, url, \"HTTP\");\n    }\n}\nexport default HttpConnection;\n//# sourceMappingURL=http.js.map"]},"metadata":{},"sourceType":"module"}