{"ast":null,"code":"const EventEmitter = require('events');\n\nconst EthereumProvider = require('ethereum-provider');\n\nconst ConnectionManager = require('../ConnectionManager');\n\nconst monitor = provider => {\n  function update(status) {\n    provider.status = status;\n    if (provider instanceof EventEmitter) provider.emit('status', status);\n  }\n\n  async function check() {\n    if (provider.inSetup) return setTimeout(check, 1000);\n\n    try {\n      if (await provider.send('eth_syncing')) {\n        update('syncing');\n        setTimeout(() => check(), 5000);\n      } else {\n        update('connected');\n      }\n    } catch (e) {\n      update('disconnected');\n    }\n  }\n\n  update('loading');\n  check();\n  provider.on('connect', () => check());\n  provider.on('close', () => update('disconnected'));\n  return provider;\n};\n\nmodule.exports = (connections, targets, options) => {\n  // If window.ethereum and injected is a target in any priority, return ethereum provider\n  if (connections.injected.__isProvider && targets.map(t => t.type).indexOf('injected') > -1) {\n    delete connections.injected.__isProvider;\n    return monitor(connections.injected);\n  }\n\n  const provider = new EthereumProvider(new ConnectionManager(connections, targets, options));\n  provider.setMaxListeners(128);\n  return monitor(provider);\n};","map":{"version":3,"sources":["/home/shashwat/Projects/Intern/node_modules/eth-provider/provider/index.js"],"names":["EventEmitter","require","EthereumProvider","ConnectionManager","monitor","provider","update","status","emit","check","inSetup","setTimeout","send","e","on","module","exports","connections","targets","options","injected","__isProvider","map","t","type","indexOf","setMaxListeners"],"mappings":"AAAA,MAAMA,YAAY,GAAGC,OAAO,CAAC,QAAD,CAA5B;;AACA,MAAMC,gBAAgB,GAAGD,OAAO,CAAC,mBAAD,CAAhC;;AACA,MAAME,iBAAiB,GAAGF,OAAO,CAAC,sBAAD,CAAjC;;AAEA,MAAMG,OAAO,GAAGC,QAAQ,IAAI;AAC1B,WAASC,MAAT,CAAiBC,MAAjB,EAAyB;AACvBF,IAAAA,QAAQ,CAACE,MAAT,GAAkBA,MAAlB;AACA,QAAIF,QAAQ,YAAYL,YAAxB,EAAsCK,QAAQ,CAACG,IAAT,CAAc,QAAd,EAAwBD,MAAxB;AACvC;;AACD,iBAAeE,KAAf,GAAwB;AACtB,QAAIJ,QAAQ,CAACK,OAAb,EAAsB,OAAOC,UAAU,CAACF,KAAD,EAAQ,IAAR,CAAjB;;AACtB,QAAI;AACF,UAAI,MAAMJ,QAAQ,CAACO,IAAT,CAAc,aAAd,CAAV,EAAwC;AACtCN,QAAAA,MAAM,CAAC,SAAD,CAAN;AACAK,QAAAA,UAAU,CAAC,MAAMF,KAAK,EAAZ,EAAgB,IAAhB,CAAV;AACD,OAHD,MAGO;AACLH,QAAAA,MAAM,CAAC,WAAD,CAAN;AACD;AACF,KAPD,CAOE,OAAOO,CAAP,EAAU;AACVP,MAAAA,MAAM,CAAC,cAAD,CAAN;AACD;AACF;;AACDA,EAAAA,MAAM,CAAC,SAAD,CAAN;AACAG,EAAAA,KAAK;AACLJ,EAAAA,QAAQ,CAACS,EAAT,CAAY,SAAZ,EAAuB,MAAML,KAAK,EAAlC;AACAJ,EAAAA,QAAQ,CAACS,EAAT,CAAY,OAAZ,EAAqB,MAAMR,MAAM,CAAC,cAAD,CAAjC;AACA,SAAOD,QAAP;AACD,CAvBD;;AAyBAU,MAAM,CAACC,OAAP,GAAiB,CAACC,WAAD,EAAcC,OAAd,EAAuBC,OAAvB,KAAmC;AAClD;AACA,MAAIF,WAAW,CAACG,QAAZ,CAAqBC,YAArB,IAAqCH,OAAO,CAACI,GAAR,CAAYC,CAAC,IAAIA,CAAC,CAACC,IAAnB,EAAyBC,OAAzB,CAAiC,UAAjC,IAA+C,CAAC,CAAzF,EAA4F;AAC1F,WAAOR,WAAW,CAACG,QAAZ,CAAqBC,YAA5B;AACA,WAAOjB,OAAO,CAACa,WAAW,CAACG,QAAb,CAAd;AACD;;AACD,QAAMf,QAAQ,GAAG,IAAIH,gBAAJ,CAAqB,IAAIC,iBAAJ,CAAsBc,WAAtB,EAAmCC,OAAnC,EAA4CC,OAA5C,CAArB,CAAjB;AACAd,EAAAA,QAAQ,CAACqB,eAAT,CAAyB,GAAzB;AACA,SAAOtB,OAAO,CAACC,QAAD,CAAd;AACD,CATD","sourcesContent":["const EventEmitter = require('events')\nconst EthereumProvider = require('ethereum-provider')\nconst ConnectionManager = require('../ConnectionManager')\n\nconst monitor = provider => {\n  function update (status) {\n    provider.status = status\n    if (provider instanceof EventEmitter) provider.emit('status', status)\n  }\n  async function check () {\n    if (provider.inSetup) return setTimeout(check, 1000)\n    try {\n      if (await provider.send('eth_syncing')) {\n        update('syncing')\n        setTimeout(() => check(), 5000)\n      } else {\n        update('connected')\n      }\n    } catch (e) {\n      update('disconnected')\n    }\n  }\n  update('loading')\n  check()\n  provider.on('connect', () => check())\n  provider.on('close', () => update('disconnected'))\n  return provider\n}\n\nmodule.exports = (connections, targets, options) => {\n  // If window.ethereum and injected is a target in any priority, return ethereum provider\n  if (connections.injected.__isProvider && targets.map(t => t.type).indexOf('injected') > -1) {\n    delete connections.injected.__isProvider\n    return monitor(connections.injected)\n  }\n  const provider = new EthereumProvider(new ConnectionManager(connections, targets, options))\n  provider.setMaxListeners(128)\n  return monitor(provider)\n}\n"]},"metadata":{},"sourceType":"script"}