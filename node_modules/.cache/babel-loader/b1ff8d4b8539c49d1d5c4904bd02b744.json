{"ast":null,"code":"const EventEmitter = require('events');\n\nconst dev = process.env.NODE_ENV === 'development';\n\nclass ConnectionManager extends EventEmitter {\n  constructor(connections, targets, options) {\n    super();\n    this.targets = targets;\n    this.connections = connections;\n    this.connected = false;\n    this.status = 'loading';\n    this.interval = options.interval || 5000;\n    this.name = options.name || 'default';\n    this.inSetup = true;\n    this.connect();\n  }\n\n  connect() {\n    let index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    if (dev && index === 0) console.log(`\\n\\n\\n\\nA connection cycle started for provider with name: ${this.name}`);\n\n    if (this.connection && this.connection.status === 'connected' && index >= this.connection.index) {\n      if (dev) console.log('Stopping connection cycle becasuse we\\'re already connected to a higher priority provider');\n    } else if (this.targets.length === 0) {\n      if (dev) console.log('No valid targets supplied');\n    } else {\n      const {\n        protocol,\n        location\n      } = this.targets[index];\n      this.connection = this.connections[protocol](location);\n      this.connection.on('error', err => {\n        if (!this.connected) return this.connectionError(index, err);\n        if (this.listenerCount('error')) return this.emit('error', err);\n        console.warn('eth-provider - Uncaught connection error: ' + err.message);\n      });\n      this.connection.on('close', summary => {\n        this.connected = false;\n        this.emit('close');\n        if (!this.closing) this.refresh();\n      });\n      this.connection.on('connect', () => {\n        this.connection.target = this.targets[index];\n        this.connection.index = index;\n        this.targets[index].status = this.connection.status;\n        this.connected = true;\n        this.inSetup = false;\n        if (dev) console.log('Successfully connected to: ' + this.targets[index].location);\n        this.emit('connect');\n      });\n      this.connection.on('data', data => this.emit('data', data));\n      this.connection.on('payload', payload => this.emit('payload', payload));\n    }\n  }\n\n  refresh() {\n    let interval = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.interval;\n    if (dev) console.log(`Reconnect queued for ${(interval / 1000).toFixed(2)}s in the future`);\n    clearTimeout(this.connectTimer);\n    this.connectTimer = setTimeout(() => this.connect(), interval);\n  }\n\n  connectionError(index, err) {\n    this.targets[index].status = err;\n\n    if (this.targets.length - 1 === index) {\n      this.inSetup = false;\n      if (dev) console.warn('eth-provider unable to connect to any targets, view connection cycle summary: ', this.targets);\n      this.refresh();\n    } else {\n      // Not last target, move on the next connection option\n      this.connect(++index);\n    }\n  }\n\n  close() {\n    this.closing = true;\n\n    if (this.connection) {\n      this.connection.close(); // Let event bubble from here\n    } else {\n      this.emit('close');\n    }\n\n    clearTimeout(this.connectTimer);\n  }\n\n  error(payload, message) {\n    let code = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;\n    this.emit('payload', {\n      id: payload.id,\n      jsonrpc: payload.jsonrpc,\n      error: {\n        message,\n        code\n      }\n    });\n  }\n\n  send(payload) {\n    if (this.inSetup) {\n      setTimeout(() => this.send(payload), 100);\n    } else if (this.connection.closed) {\n      this.error(payload, 'Not connected');\n    } else {\n      this.connection.send(payload);\n    }\n  }\n\n}\n\nmodule.exports = ConnectionManager;","map":{"version":3,"sources":["/home/shashwat/Projects/Dyeus/node_modules/eth-provider/ConnectionManager/index.js"],"names":["EventEmitter","require","dev","process","env","NODE_ENV","ConnectionManager","constructor","connections","targets","options","connected","status","interval","name","inSetup","connect","index","console","log","connection","length","protocol","location","on","err","connectionError","listenerCount","emit","warn","message","summary","closing","refresh","target","data","payload","toFixed","clearTimeout","connectTimer","setTimeout","close","error","code","id","jsonrpc","send","closed","module","exports"],"mappings":"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","sourcesContent":["const EventEmitter = require('events')\n\nconst dev = process.env.NODE_ENV === 'development'\n\nclass ConnectionManager extends EventEmitter {\n  constructor (connections, targets, options) {\n    super()\n    this.targets = targets\n    this.connections = connections\n    this.connected = false\n    this.status = 'loading'\n    this.interval = options.interval || 5000\n    this.name = options.name || 'default'\n    this.inSetup = true\n    this.connect()\n  }\n\n  connect (index = 0) {\n    if (dev && index === 0) console.log(`\\n\\n\\n\\nA connection cycle started for provider with name: ${this.name}`)\n\n    if (this.connection && this.connection.status === 'connected' && index >= this.connection.index) {\n      if (dev) console.log('Stopping connection cycle becasuse we\\'re already connected to a higher priority provider')\n    } else if (this.targets.length === 0) {\n      if (dev) console.log('No valid targets supplied')\n    } else {\n      const { protocol, location } = this.targets[index]\n      this.connection = this.connections[protocol](location)\n\n      this.connection.on('error', err => {\n        if (!this.connected) return this.connectionError(index, err)\n        if (this.listenerCount('error')) return this.emit('error', err)\n        console.warn('eth-provider - Uncaught connection error: ' + err.message)\n      })\n\n      this.connection.on('close', (summary) => {\n        this.connected = false\n        this.emit('close')\n        if (!this.closing) this.refresh()\n      })\n\n      this.connection.on('connect', () => {\n        this.connection.target = this.targets[index]\n        this.connection.index = index\n        this.targets[index].status = this.connection.status\n        this.connected = true\n        this.inSetup = false\n        if (dev) console.log('Successfully connected to: ' + this.targets[index].location)\n        this.emit('connect')\n      })\n\n      this.connection.on('data', data => this.emit('data', data))\n      this.connection.on('payload', payload => this.emit('payload', payload))\n    }\n  }\n\n  refresh (interval = this.interval) {\n    if (dev) console.log(`Reconnect queued for ${(interval / 1000).toFixed(2)}s in the future`)\n    clearTimeout(this.connectTimer)\n    this.connectTimer = setTimeout(() => this.connect(), interval)\n  }\n\n  connectionError (index, err) {\n    this.targets[index].status = err\n    if (this.targets.length - 1 === index) {\n      this.inSetup = false\n      if (dev) console.warn('eth-provider unable to connect to any targets, view connection cycle summary: ', this.targets)\n      this.refresh()\n    } else { // Not last target, move on the next connection option\n      this.connect(++index)\n    }\n  }\n\n  close () {\n    this.closing = true\n    if (this.connection) {\n      this.connection.close() // Let event bubble from here\n    } else {\n      this.emit('close')\n    }\n    clearTimeout(this.connectTimer)\n  }\n\n  error (payload, message, code = -1) {\n    this.emit('payload', { id: payload.id, jsonrpc: payload.jsonrpc, error: { message, code } })\n  }\n\n  send (payload) {\n    if (this.inSetup) {\n      setTimeout(() => this.send(payload), 100)\n    } else if (this.connection.closed) {\n      this.error(payload, 'Not connected')\n    } else {\n      this.connection.send(payload)\n    }\n  }\n}\n\nmodule.exports = ConnectionManager\n"]},"metadata":{},"sourceType":"script"}